<script>
    // 게임 요소들
    let player = document.getElementById('player');
    let gameContainer = document.getElementById('gameContainer');
    let coordinates = document.getElementById('coordinates');
    let gameStats = document.getElementById('gameStats');
    
    // 게임 설정
// 화면 크기 (보이는 화면)
const screenWidth = 1800;
const screenHeight = 900;

// 실제 맵 크기 (가상의 맵, 2배)
const mapWidth = 3600;
const mapHeight = 900;

// 카메라 오프셋
let cameraX = 0;
    const playerSize = 40;
    const groundHeight = 90;
    
    // 플레이어 상태
    let playerX = 100;
    let playerY = screenHeight - groundHeight - playerSize;
    let velocityX = 0;
    let velocityY = 0;
    
    // 게임 설정 (구글 시트에서 가져올 값들)
    let moveSpeed = 7;
    let jumpPower = 15;
    let gravity = 0.6;
    let friction = 0.8;
    let airResistance = 0.95;
    let bulletSpeed = 10;
    let fireRate = 300; // 밀리초
    
    // 주사위 관련 변수
    let diceArray = [];
    let diceShot = 0;
    let totalDamage = 0;
    let lastFireTime = 0;

    //구름 관련 변수
    let clouds = [];

    //튜토리얼 변수
    let tutorialSigns = [];

    // 적 관련 변수 (새로 추가)
    let enemies = [];
    let damageIndicators = [];
    
    // 입력 상태
    let keys = {
    left: false,
    right: false,
    jump: false,
    shoot: false,
    arrowLeft: false,
    arrowRight: false,
    arrowUp: false,
    arrowDown: false
};
    
    let isOnGround = false;
    //게임 루프
    function gameLoop() {
    handleInput();
    updatePhysics();
    updateDice();
    updateEnemies();          // 추가
    updateDamageIndicators(); // 추가
    checkDiceEnemyCollisions(); // 추가
    updatePlayerPosition();
    updateTutorialSigns(); //튜토리얼
    updateClouds();
    updateUI();
    requestAnimationFrame(gameLoop);
}
    
    // 입력 처리
function handleInput() {
    // 디버깅용 - keys 상태 확인
    if (keys.left || keys.right || keys.jump || keys.shoot || keys.arrowLeft || keys.arrowRight || keys.arrowUp || keys.arrowDown) {
        console.log('Keys active:', keys);
    }
    
    // 좌우 이동 (땅에서 더 빠르게)
    if (keys.left) {
        console.log('Moving left!'); // 디버깅용
        if (isOnGround) {
            velocityX -= moveSpeed * 1.0;
        } else {
            velocityX -= moveSpeed * 0.1;
        }
    }
    if (keys.right) {
        console.log('Moving right!'); // 디버깅용
        if (isOnGround) {
            velocityX += moveSpeed * 0.15;
        } else {
            velocityX += moveSpeed * 0.1;
        }
    }
    
    // 점프 (땅에 있을 때만)
    if (keys.jump && isOnGround) {
        console.log('Jumping!'); // 디버깅용
        velocityY = -jumpPower;
        isOnGround = false;
    }
    
    // 주사위 발사 (S키)
    if (keys.shoot) {
        console.log('Shooting!'); // 디버깅용
        fireDice(); // 기본 우측 발사
    }
    
    // 화살표키로 방향 발사
    if (keys.arrowLeft) {
        fireDice(-1, 0); // 왼쪽
    }
    if (keys.arrowRight) {
        fireDice(1, 0); // 오른쪽
    }
    if (keys.arrowUp) {
        fireDice(0, -1); // 위쪽
    }
    if (keys.arrowDown) {
        fireDice(0, 1); // 아래쪽
    }
}

    // 주사위 눈 생성 함수 - 개선된 버전
    function createDiceFace(value) {
        let dotsHTML = '';
        
        // 주사위 눈에 따라 점 생성
        for (let i = 0; i < value; i++) {
            dotsHTML += '<div class="dice-dot"></div>';
        }
        
        return dotsHTML;
    }

    // 주사위 발사 함수
    function fireDice(directionX = 1, directionY = 0) {
    const currentTime = Date.now();
    if (currentTime - lastFireTime < fireRate) return;
    
    lastFireTime = currentTime;
    diceShot++;




    // 주사위 생성
    const dice = {
        element: document.createElement('div'),
        x: playerX + playerSize / 2,
        y: playerY + playerSize / 2,
        velocityX: bulletSpeed * directionX,
        velocityY: bulletSpeed * directionY,
        value: Math.floor(Math.random() * 6) + 1,
        life: 300,
        rollCounter: 0
    };
        
        // 주사위 요소 설정
        dice.element.className = `dice dice-face-${dice.value}`;
        dice.element.innerHTML = createDiceFace(dice.value);
        dice.element.style.left = dice.x + 'px';
        dice.element.style.top = dice.y + 'px';
        
        gameContainer.appendChild(dice.element);
        diceArray.push(dice);
        
        totalDamage += dice.value;
    }
    // 허수아비 생성 함수
    function createTrainingDummy() {
        const dummy = {
            element: document.createElement('div'),
            x: mapWidth - 200, // 맵의 우측 끝 근처에 배치
            y: screenHeight - groundHeight - 60,
            width: 40,
            height: 60,
            maxHp: 1000,
            currentHp: 1000,
            type: 'dummy'
        };
        
        dummy.element.className = 'training-dummy';
        dummy.element.style.left = dummy.x + 'px';
        dummy.element.style.top = dummy.y + 'px';
        
        const hpBar = document.createElement('div');
        hpBar.className = 'enemy-hp-bar';
        hpBar.innerHTML = `
            <div class="hp-bar-background">
                <div class="hp-bar-fill"></div>
                <div class="hp-bar-text">${dummy.currentHp}/${dummy.maxHp}</div>
            </div>
        `;
        dummy.element.appendChild(hpBar);
        
        gameContainer.appendChild(dummy.element);
        enemies.push(dummy);
    }

    // 적 업데이트 함수
function updateEnemies() {
    enemies.forEach(enemy => {
        // 카메라 오프셋 적용
        const screenX = enemy.x - cameraX;
        enemy.element.style.left = screenX + 'px';
        
        if (enemy.type === 'dummy') {
            const hpFill = enemy.element.querySelector('.hp-bar-fill');
            const hpText = enemy.element.querySelector('.hp-bar-text');
            
            const hpPercent = (enemy.currentHp / enemy.maxHp) * 100;
            hpFill.style.width = hpPercent + '%';
            hpText.textContent = `${enemy.currentHp}/${enemy.maxHp}`;
        }
    });
}

    // 데미지 표시기 생성 (반원 범위)
function createDamageIndicator(enemyX, enemyY, enemyWidth, diceValue) {
    // 적의 머리 중앙 위치
    const headCenterX = enemyX + enemyWidth / 2;
    const headY = enemyY - 10; // 머리 위쪽
    
    // 반원 범위에서 랜덤 위치 계산
    const radius = 40; // 반원 반지름
    const angle = Math.random() * Math.PI; // 0 ~ π (반원)
    
    const offsetX = Math.cos(angle) * (Math.random() * radius);
    const offsetY = -Math.sin(angle) * (Math.random() * radius); // 위쪽으로만
    
    const indicator = {
        element: document.createElement('div'),
        x: headCenterX + offsetX,
        y: headY + offsetY,
        life: 150, // 조금 더 짧게
        diceValue: diceValue
    };
    
    indicator.element.className = 'damage-indicator';
    indicator.element.textContent = `-${diceValue}`;
    
    // 카메라 오프셋 적용된 위치
    const screenX = indicator.x - cameraX;
    indicator.element.style.left = screenX + 'px';
    indicator.element.style.top = indicator.y + 'px';
    
    gameContainer.appendChild(indicator.element);
    damageIndicators.push(indicator);
}

    // 데미지 표시기 업데이트
function updateDamageIndicators() {
    for (let i = damageIndicators.length - 1; i >= 0; i--) {
        const indicator = damageIndicators[i];
        
        // 카메라 오프셋 적용
        const screenX = indicator.x - cameraX;
        indicator.element.style.left = screenX + 'px';
        
        indicator.life--;
        
        if (indicator.life < 60) {
            const opacity = indicator.life / 60;
            indicator.element.style.opacity = opacity;
        }
        
        if (indicator.life <= 0) {
            indicator.element.remove();
            damageIndicators.splice(i, 1);
        }
    }
}

    // 주사위와 적 충돌 검사
    function checkDiceEnemyCollisions() {
        for (let i = diceArray.length - 1; i >= 0; i--) {
            const dice = diceArray[i];
            
            for (let j = 0; j < enemies.length; j++) {
                const enemy = enemies[j];
                
                if (dice.x < enemy.x + enemy.width &&
                    dice.x + 25 > enemy.x &&
                    dice.y < enemy.y + enemy.height &&
                    dice.y + 25 > enemy.y) {
                    
                    enemy.currentHp -= dice.value;
                    if (enemy.currentHp < 0) enemy.currentHp = 0;
                    
                    createDamageIndicator(enemy.x, enemy.y, enemy.width, dice.value);
                    
                    dice.element.remove();
                    diceArray.splice(i, 1);
                    break;
                }
            }
        }
    }
    // 주사위 업데이트
    function updateDice() {
        for (let i = diceArray.length - 1; i >= 0; i--) {
            const dice = diceArray[i];
            
            // 주사위 이동
            dice.x += dice.velocityX;
            dice.y += dice.velocityY;
            
            // 주사위 눈 랜덤 변경 (더 안정적으로)
            dice.rollCounter++;
            if (dice.rollCounter % 40 === 0) { // 20프레임마다 변경 (더 천천히)
                const oldValue = dice.value;
                dice.value = Math.floor(Math.random() * 6) + 1;
                
                // 값이 바뀌었을 때만 업데이트
                if (oldValue !== dice.value) {
                    dice.element.className = `dice dice-face-${dice.value}`;
                    dice.element.innerHTML = createDiceFace(dice.value);
                    
                    // 총 데미지 업데이트 (이전 값 빼고 새 값 더하기)
                    totalDamage = totalDamage - oldValue + dice.value;
                }
            }
            
            // 위치 업데이트 (카메라 오프셋 적용)
const screenX = dice.x - cameraX;
dice.element.style.left = screenX + 'px';
dice.element.style.top = dice.y + 'px';
            
            // 수명 감소
            dice.life--;
            
            // 맵 밖으로 나가거나 수명이 다하면 제거
if (dice.x > mapWidth || dice.y > screenHeight || dice.life <= 0 || dice.x < 0) {
                dice.element.remove();
                diceArray.splice(i, 1);
            }
        }
    }
    
    // UI 업데이트
    function updateUI() {
        gameStats.textContent = `주사위: ${diceShot}발 | 총 데미지: ${totalDamage}`;
    }
   
    // 구름 생성 함수
function createClouds() {
    const cloudTypes = ['cloud-small', 'cloud-medium', 'cloud-large'];
    
    for (let i = 0; i < 8; i++) {
        const cloud = {
            element: document.createElement('div'),
            x: Math.random() * mapWidth,
            y: Math.random() * 200 + 50, // 하늘 위쪽에만
            type: cloudTypes[Math.floor(Math.random() * cloudTypes.length)]
        };
        
        cloud.element.className = `cloud ${cloud.type}`;
        cloud.element.style.left = cloud.x + 'px';
        cloud.element.style.top = cloud.y + 'px';
        
        gameContainer.appendChild(cloud.element);
        clouds.push(cloud);
    }
}

// 구름 위치 업데이트 함수
function updateClouds() {
    clouds.forEach(cloud => {
        // 카메라 오프셋 적용
        const screenX = cloud.x - cameraX;
        cloud.element.style.left = screenX + 'px';
    });
}
// 튜토리얼 사인 생성 함수
function createTutorialSigns() {
    const tutorials = [
        {
            x: 400,
            y: screenHeight - groundHeight - 180,
            text: "A/D키로\n좌우 이동",
            arrow: "←→"
        },
        {
            x: 900,
            y: screenHeight - groundHeight - 180,
            text: "스페이스바로\n점프",
            arrow: "↑"
        },
        {
            x: 1400,
            y: screenHeight - groundHeight - 180,
            text: "화살표키로\n주사위 발사",
            arrow: "🎲"
        },
        {
            x: mapWidth - 500,
            y: screenHeight - groundHeight - 200,
            text: "허수아비를\n공격해보세요!",
            arrow: "🎯"
        }
    ];
    
    tutorials.forEach((tutorial, index) => {
        // 사인 생성
        const sign = {
            element: document.createElement('div'),
            x: tutorial.x,
            y: tutorial.y,
            id: `tutorial-${index}`
        };
        
        sign.element.className = 'tutorial-sign';
        sign.element.innerHTML = tutorial.text.replace('\n', '<br>');
        sign.element.style.left = tutorial.x + 'px';
        sign.element.style.top = tutorial.y + 'px';
        
        gameContainer.appendChild(sign.element);
        tutorialSigns.push(sign);
        
        // 화살표 생성
        const arrow = {
            element: document.createElement('div'),
            x: tutorial.x,
            y: tutorial.y - 40,
            signIndex: index
        };
        
        arrow.element.className = 'tutorial-arrow';
        arrow.element.textContent = tutorial.arrow;
        arrow.element.style.left = (tutorial.x + 100) + 'px';
        arrow.element.style.top = (tutorial.y - 40) + 'px';
        
        gameContainer.appendChild(arrow.element);
        tutorialSigns.push(arrow);
    });
}

// 튜토리얼 업데이트 함수
function updateTutorialSigns() {
    tutorialSigns.forEach(sign => {
        // 카메라 오프셋 적용
        const screenX = sign.x - cameraX;
        sign.element.style.left = screenX + 'px';
    });
}
    // 물리 엔진
    function updatePhysics() {
        // 중력 적용
        velocityY += gravity;
        
        // 공기 저항
if (!isOnGround) {
    velocityX *= airResistance;
} else {
    // 땅에서의 마찰
    velocityX *= friction;
}
        
        // 최대 속도 제한
        const maxVelocityX = moveSpeed;
        const maxVelocityY = 25;
        
        if (velocityX > maxVelocityX) velocityX = maxVelocityX;
        if (velocityX < -maxVelocityX) velocityX = -maxVelocityX;
        if (velocityY > maxVelocityY) velocityY = maxVelocityY;
        
        // 위치 업데이트
        playerX += velocityX;
        playerY += velocityY;
        
        // 경계 충돌 검사
        checkCollisions();
    }
    
    // 충돌 검사
    function checkCollisions() {
        // 좌우 벽 충돌 (맵 크기 기준)
if (playerX < 0) {
    playerX = 0;
    velocityX = 0;
}
if (playerX > mapWidth - playerSize) {
    playerX = mapWidth - playerSize;
    velocityX = 0;
}
        
        // 땅 충돌
        // 땅 충돌 (캐릭터 발이 땅 표면에 정확히 닿도록)
const groundSurfaceY = screenHeight - groundHeight; // 땅의 표면 위치
const groundY = groundSurfaceY - playerSize; // 캐릭터가 땅 위에 서는 위치
if (playerY >= groundY) {
    playerY = groundY;
    velocityY = 0;
    isOnGround = true;
} else {
    isOnGround = false;
}
        
        // 천장 충돌
        if (playerY < 0) {
            playerY = 0;
            velocityY = 0;
        }
    }
    
    // 플레이어 위치 업데이트
function updatePlayerPosition() {
    updateCamera();
    
    // 카메라 오프셋을 적용한 화면상 위치
    const screenX = playerX - cameraX;
    
    player.style.left = Math.round(screenX) + 'px';
    player.style.top = Math.round(playerY) + 'px';
    coordinates.textContent = `X: ${Math.round(playerX)}, Y: ${Math.round(playerY)} | Camera: ${Math.round(cameraX)}`;
}

// 카메라 업데이트 함수 (부드러운 전환)
function updateCamera() {
    const followPosition = screenWidth * 1/3; // 600px
    const leftBoundary = followPosition; // 600px
const rightBoundary = mapWidth - (screenWidth - followPosition); // 2400px
    
    let targetCameraX;
    
    if (playerX < leftBoundary) {
        // 좌측 구간: 카메라 고정
        targetCameraX = 0;
    } else if (playerX > rightBoundary) {
        // 우측 구간: 카메라 고정
        targetCameraX = mapWidth - screenWidth;
    } else {
        // 중간 구간: 캐릭터 따라가기
        targetCameraX = playerX - followPosition;
    }
    
    // 부드러운 카메라 이동 (선택사항)
    // cameraX += (targetCameraX - cameraX) * 0.1;
    
    // 즉시 이동
    cameraX = targetCameraX;
}
    
    // 키보드 이벤트 처리
    document.addEventListener('keydown', function(event) {
        console.log('Key pressed:', event.key, event.code); // 디버깅용
        
        switch(event.key.toLowerCase()) {
            case 'a':
                keys.left = true;
                event.preventDefault();
                break;
            case 'd':
                keys.right = true;
                event.preventDefault();
                break;
            case ' ': //스페이스 바
                keys.jump = true;
                event.preventDefault();
                break;
            case 's':
                keys.shoot = true;
                event.preventDefault();
                break;
            case 'arrowleft':
                keys.arrowLeft = true;
                event.preventDefault();
                break;
            case 'arrowright':
                keys.arrowRight = true;
                event.preventDefault();
                break;
            case 'arrowup':
                keys.arrowUp = true;
                event.preventDefault();
                break;
            case 'arrowdown':
                keys.arrowDown = true;
                event.preventDefault();
                break;
        }
    });
    
    document.addEventListener('keyup', function(event) {
        switch(event.key.toLowerCase()) {
            case 'a':
                keys.left = false;
                event.preventDefault();
                break;
            case 'd':
                keys.right = false;
                event.preventDefault();
                break;
            case ' ': // 스페이스바
                keys.jump = false;
                event.preventDefault();
                break;
            case 's':
                keys.shoot = false;
                event.preventDefault();
                break;
            case 'arrowleft':
                keys.arrowLeft = false;
                event.preventDefault();
                break;
            case 'arrowright':
                keys.arrowRight = false;
                event.preventDefault();
                break;
            case 'arrowup':
                keys.arrowUp = false;
                event.preventDefault();
                break;
            case 'arrowdown':
                keys.arrowDown = false;
                event.preventDefault();
                break;
        }
    });
    
    // 구글 시트 연동 함수들
    function loadPosition() {
        google.script.run
            .withSuccessHandler(function(data) {
                playerX = data.playerX;
                playerY = data.playerY;
                moveSpeed = data.moveSpeed;
                jumpPower = data.jumpPower;
                gravity = data.gravity;
                
                // 속도 초기화
                velocityX = 0;
                velocityY = 0;
                
                updatePlayerPosition();
                alert('데이터를 불러왔습니다!');
            })
            .withFailureHandler(function(error) {
                alert('데이터를 불러오는데 실패했습니다: ' + error);
            })
            .getGameData();
    }
    
    function savePosition() {
        google.script.run
            .withSuccessHandler(function(result) {
                alert('위치가 저장되었습니다!');
            })
            .withFailureHandler(function(error) {
                alert('저장에 실패했습니다: ' + error);
            })
            .saveGameData(Math.round(playerX), Math.round(playerY));
    }
    
    function resetPosition() {
        google.script.run
            .withSuccessHandler(function(result) {
                playerX = 100;
                playerY = screenHeight - groundHeight - playerSize; // 땅 표면 바로 위
                velocityX = 0;
                velocityY = 0;
                diceShot = 0;
                totalDamage = 0;
                
                // 모든 주사위 제거
                diceArray.forEach(dice => dice.element.remove());
                diceArray = [];
                
                updatePlayerPosition();
                alert('게임이 초기화되었습니다!');
            })
            .withFailureHandler(function(error) {
                alert('초기화에 실패했습니다: ' + error);
            })
            .resetGame();
    }
    
    // 게임 시작
    function startGame() {
        updatePlayerPosition();
        createTrainingDummy(); // 허수아비 생성
        gameLoop();
        createClouds();
        createTutorialSigns();
    }
    
    // 페이지 로드 시 초기화
    window.onload = function() {
        // 게임 설정 로드
        google.script.run
            .withSuccessHandler(function(data) {
                if (data) {
                    moveSpeed = data.moveSpeed || moveSpeed;
                    jumpPower = data.jumpPower || jumpPower;
                    gravity = data.gravity || gravity;
                    bulletSpeed = data.bulletSpeed || bulletSpeed;
                    fireRate = data.fireRate || fireRate;
                }
                startGame();
            })
            .withFailureHandler(function(error) {
                console.log('설정을 불러오는데 실패했지만 기본값으로 시작합니다.');
                startGame();
            })
            .getGameSettings();
    };
</script>
