<script>
    // 게임 요소들
    let player = document.getElementById('player');
    let gameContainer = document.getElementById('gameContainer');
    let coordinates = document.getElementById('coordinates');
    let gameStats = document.getElementById('gameStats');
    
    // 게임 설정
// 화면 크기 (보이는 화면)
const screenWidth = 1800;
const screenHeight = 900;

// 실제 맵 크기 (가상의 맵, 2배)
const mapWidth = 3600;
const mapHeight = 900;

// 카메라 오프셋
let cameraX = 0;
    const playerSize = 40;
    const groundHeight = 90;
    
    // 플레이어 상태
    let playerX = 100;
    let playerY = screenHeight - groundHeight - playerSize;
    let velocityX = 0;
    let velocityY = 0;
    
    // 게임 설정 (구글 시트에서 가져올 값들)
    let moveSpeed = 7;
    let jumpPower = 15;
    let gravity = 0.6;
    let friction = 0.8;
    let airResistance = 0.95;
    let bulletSpeed = 10;
    let fireRate = 300; // 밀리초
    
    // 주사위 관련 변수
    let diceArray = [];
    let diceShot = 0;
    let totalDamage = 0;
    let lastFireTime = 0;

    //구름 관련 변수
    let clouds = [];

    //튜토리얼 변수
    let tutorialSigns = [];
// 포털 관련 변수들
let mapPortal = null;
let leftPortal = null;
let portalParticles = [];
let leftPortalParticles = [];
let showPortalMessage = false;
let showLeftPortalMessage = false;

    // 적 관련 변수 (새로 추가)
    let enemies = [];
    let damageIndicators = [];
    
    // 입력 상태
    let keys = {
    left: false,
    right: false,
    jump: false,
    shoot: false,
    arrowLeft: false,
    arrowRight: false,
    arrowUp: false,
    arrowDown: false
};
    
    let isOnGround = false;
    //게임 루프
    function gameLoop() {
    handleInput();
    updatePhysics();
    updateDice();
    updateEnemies();
    updateDamageIndicators();
    checkDiceEnemyCollisions();
    updatePlayerPosition();
    updateTutorialSigns();
    updateClouds();
    updatePortal();           // 추가
    updatePortalParticles();  // 추가
    updateUI();
    requestAnimationFrame(gameLoop);
}
    //입력 처리
    function handleInput() {
    // 좌우 이동 (땅에서 더 빠르게)
    if (keys.left) {
        if (isOnGround) {
            velocityX -= moveSpeed * 1.0;
        } else {
            velocityX -= moveSpeed * 0.1;
        }
    }
    if (keys.right) {
        if (isOnGround) {
            velocityX += moveSpeed * 0.15;
        } else {
            velocityX += moveSpeed * 0.1;
        }
    }
    
    // 점프 (땅에 있을 때만)
    if (keys.jump && isOnGround) {
        velocityY = -jumpPower;
        isOnGround = false;
    }
    
    // 주사위 발사 (S키)
    if (keys.shoot) {
        fireDice(); // 기본 우측 발사
    }
    
    // 화살표키로 방향 발사
    if (keys.arrowLeft) {
        fireDice(-1, 0); // 왼쪽
    }
    if (keys.arrowRight) {
        fireDice(1, 0); // 오른쪽
    }
    if (keys.arrowUp) {
        fireDice(0, -1); // 위쪽
    }
    if (keys.arrowDown) {
        fireDice(0, 1); // 아래쪽
    }
}

    // 주사위 눈 생성 함수 - 개선된 버전
    function createDiceFace(value) {
        let dotsHTML = '';
        
        // 주사위 눈에 따라 점 생성
        for (let i = 0; i < value; i++) {
            dotsHTML += '<div class="dice-dot"></div>';
        }
        
        return dotsHTML;
    }

    // 주사위 발사 함수
    function fireDice(directionX = 1, directionY = 0) {
    const currentTime = Date.now();
    if (currentTime - lastFireTime < fireRate) return;
    
    lastFireTime = currentTime;
    diceShot++;




    // 주사위 생성
    const dice = {
        element: document.createElement('div'),
        x: playerX + playerSize / 2,
        y: playerY + playerSize / 2,
        velocityX: bulletSpeed * directionX,
        velocityY: bulletSpeed * directionY,
        value: Math.floor(Math.random() * 6) + 1,
        life: 300,
        rollCounter: 0
    };
        
        // 주사위 요소 설정
        dice.element.className = `dice dice-face-${dice.value}`;
        dice.element.innerHTML = createDiceFace(dice.value);
        dice.element.style.left = dice.x + 'px';
        dice.element.style.top = dice.y + 'px';
        
        gameContainer.appendChild(dice.element);
        diceArray.push(dice);
        
        totalDamage += dice.value;
    }
    // 허수아비 생성 함수
function createTrainingDummy() {
    const dummy = {
        element: document.createElement('div'),
        x: mapWidth - 600, // 나무 간판 밑으로 이동 (더 왼쪽으로)
        y: screenHeight - groundHeight - 60,
            width: 40,
            height: 60,
            maxHp: 1000,
            currentHp: 1000,
            type: 'dummy'
        };
        
        dummy.element.className = 'training-dummy';
        dummy.element.style.left = dummy.x + 'px';
        dummy.element.style.top = dummy.y + 'px';
        
        const hpBar = document.createElement('div');
        hpBar.className = 'enemy-hp-bar';
        hpBar.innerHTML = `
            <div class="hp-bar-background">
                <div class="hp-bar-fill"></div>
                <div class="hp-bar-text">${dummy.currentHp}/${dummy.maxHp}</div>
            </div>
        `;
        dummy.element.appendChild(hpBar);
        
        gameContainer.appendChild(dummy.element);
        enemies.push(dummy);
    }

    // 적 업데이트 함수
function updateEnemies() {
    enemies.forEach(enemy => {
        // 카메라 오프셋 적용하여 화면상 위치 계산
        const screenX = enemy.x - cameraX;
        enemy.element.style.left = screenX + 'px';
        enemy.element.style.top = enemy.y + 'px'; // Y 위치도 명시적으로 설정
        
        if (enemy.type === 'dummy') {
            const hpFill = enemy.element.querySelector('.hp-bar-fill');
            const hpText = enemy.element.querySelector('.hp-bar-text');
            
            const hpPercent = (enemy.currentHp / enemy.maxHp) * 100;
            hpFill.style.width = hpPercent + '%';
            hpText.textContent = `${enemy.currentHp}/${enemy.maxHp}`;
        }
    });
}

    // 데미지 표시기 생성 (반원 범위)
function createDamageIndicator(enemyX, enemyY, enemyWidth, diceValue) {
    // 적의 머리 중앙 위치
    const headCenterX = enemyX + enemyWidth / 2;
    const headY = enemyY - 10; // 머리 위쪽
    
    // 반원 범위에서 랜덤 위치 계산
    const radius = 40; // 반원 반지름
    const angle = Math.random() * Math.PI; // 0 ~ π (반원)
    
    const offsetX = Math.cos(angle) * (Math.random() * radius);
    const offsetY = -Math.sin(angle) * (Math.random() * radius); // 위쪽으로만
    
    const indicator = {
        element: document.createElement('div'),
        x: headCenterX + offsetX,
        y: headY + offsetY,
        life: 150, // 조금 더 짧게
        diceValue: diceValue
    };
    
    indicator.element.className = 'damage-indicator';
    indicator.element.textContent = `-${diceValue}`;
    
    // 카메라 오프셋 적용된 위치
    const screenX = indicator.x - cameraX;
    indicator.element.style.left = screenX + 'px';
    indicator.element.style.top = indicator.y + 'px';
    
    gameContainer.appendChild(indicator.element);
    damageIndicators.push(indicator);
}

    // 데미지 표시기 업데이트
function updateDamageIndicators() {
    for (let i = damageIndicators.length - 1; i >= 0; i--) {
        const indicator = damageIndicators[i];
        
        // 카메라 오프셋 적용
        const screenX = indicator.x - cameraX;
        indicator.element.style.left = screenX + 'px';
        
        indicator.life--;
        
        if (indicator.life < 60) {
            const opacity = indicator.life / 60;
            indicator.element.style.opacity = opacity;
        }
        
        if (indicator.life <= 0) {
            indicator.element.remove();
            damageIndicators.splice(i, 1);
        }
    }
}

    // 주사위와 적 충돌 검사
    function checkDiceEnemyCollisions() {
        for (let i = diceArray.length - 1; i >= 0; i--) {
            const dice = diceArray[i];
            
            for (let j = 0; j < enemies.length; j++) {
                const enemy = enemies[j];
                
                if (dice.x < enemy.x + enemy.width &&
                    dice.x + 25 > enemy.x &&
                    dice.y < enemy.y + enemy.height &&
                    dice.y + 25 > enemy.y) {
                    
                    enemy.currentHp -= dice.value;
                    if (enemy.currentHp < 0) enemy.currentHp = 0;
                    
                    createDamageIndicator(enemy.x, enemy.y, enemy.width, dice.value);
                    
                    dice.element.remove();
                    diceArray.splice(i, 1);
                    break;
                }
            }
        }
    }
    // 주사위 업데이트
    function updateDice() {
        for (let i = diceArray.length - 1; i >= 0; i--) {
            const dice = diceArray[i];
            
            // 주사위 이동
            dice.x += dice.velocityX;
            dice.y += dice.velocityY;
            
            // 주사위 눈 랜덤 변경 (더 안정적으로)
            dice.rollCounter++;
            if (dice.rollCounter % 40 === 0) { // 20프레임마다 변경 (더 천천히)
                const oldValue = dice.value;
                dice.value = Math.floor(Math.random() * 6) + 1;
                
                // 값이 바뀌었을 때만 업데이트
                if (oldValue !== dice.value) {
                    dice.element.className = `dice dice-face-${dice.value}`;
                    dice.element.innerHTML = createDiceFace(dice.value);
                    
                    // 총 데미지 업데이트 (이전 값 빼고 새 값 더하기)
                    totalDamage = totalDamage - oldValue + dice.value;
                }
            }
            
            // 위치 업데이트 (카메라 오프셋 적용)
const screenX = dice.x - cameraX;
dice.element.style.left = screenX + 'px';
dice.element.style.top = dice.y + 'px';
            
            // 수명 감소
            dice.life--;
            
            // 맵 밖으로 나가거나 수명이 다하면 제거
if (dice.x > mapWidth || dice.y > screenHeight || dice.life <= 0 || dice.x < 0) {
                dice.element.remove();
                diceArray.splice(i, 1);
            }
        }
    }
    
    // UI 업데이트
    function updateUI() {
        gameStats.textContent = `주사위: ${diceShot}발 | 총 데미지: ${totalDamage}`;
    }
   
    // 구름 생성 함수
function createClouds() {
    const cloudTypes = ['cloud-small', 'cloud-medium', 'cloud-large'];
    
    for (let i = 0; i < 8; i++) {
        const cloud = {
            element: document.createElement('div'),
            x: Math.random() * mapWidth,
            y: Math.random() * 200 + 50, // 하늘 위쪽에만
            type: cloudTypes[Math.floor(Math.random() * cloudTypes.length)]
        };
        
        cloud.element.className = `cloud ${cloud.type}`;
        cloud.element.style.left = cloud.x + 'px';
        cloud.element.style.top = cloud.y + 'px';
        
        gameContainer.appendChild(cloud.element);
        clouds.push(cloud);
    }
}

// 구름 위치 업데이트 함수
function updateClouds() {
    clouds.forEach(cloud => {
        // 카메라 오프셋 적용
        const screenX = cloud.x - cameraX;
        cloud.element.style.left = screenX + 'px';
    });
}
// game-script.html에 추가/수정할 코드

// 맵 관련 변수 추가 (기존 변수들과 함께)
let maps = {
    tutorial: {
        name: 'tutorial',
        hasEnemies: true,
        hasTutorialSigns: true,
        portals: {
            right: 'stage1', // 우측 포털로 stage1으로 이동
            left: null       // 좌측 포털 없음
        }
    },
    stage1: {
        name: 'stage1',
        hasEnemies: false,
        hasTutorialSigns: false,
        portals: {
            right: null,      // 우측 포털 없음 (나중에 추가 가능)
            left: 'tutorial'  // 좌측 포털로 tutorial로 돌아가기
        }
    }
};

// 맵 초기화 함수
function initializeMap(mapName, fromPortal = false) {
    currentMap = mapName;
    const mapData = maps[mapName];
    
    // 기존 요소들 제거
    clearMapElements();
    
    // 플레이어 위치 초기화
    if (mapName === 'tutorial') {
        if (fromPortal) {
            // 맵1에서 돌아올 때는 우측 포털 근처에 배치
            playerX = mapWidth - 300; // 우측 포털 근처
        } else {
            // 첫 시작이거나 초기화할 때는 왼쪽에 배치
            playerX = 100;
        }
    } else if (mapName === 'stage1') {
        playerX = 100; // stage1 시작 위치
    }
    playerY = screenHeight - groundHeight - playerSize;
    velocityX = 0;
    velocityY = 0;
    
    // 카메라 위치 초기화
    cameraX = 0;
    
    // 맵별 요소 생성
    createMapElements(mapData);
    
    updatePlayerPosition();
}

// 맵 요소들 제거 함수
function clearMapElements() {
    // 적들 제거
    enemies.forEach(enemy => {
        if (enemy.element && enemy.element.parentNode) {
            enemy.element.remove();
        }
    });
    enemies = [];
    
    // 튜토리얼 사인들 제거
    tutorialSigns.forEach(sign => {
        if (sign.element && sign.element.parentNode) {
            sign.element.remove();
        }
    });
    tutorialSigns = [];
    
    // 포털들 제거
    if (mapPortal && mapPortal.element && mapPortal.element.parentNode) {
        mapPortal.element.remove();
    }
    if (leftPortal && leftPortal.element && leftPortal.element.parentNode) {
        leftPortal.element.remove();
    }
    mapPortal = null;
    leftPortal = null;
    
    // 포털 파티클들 제거
    portalParticles.forEach(particle => {
        if (particle.element && particle.element.parentNode) {
            particle.element.remove();
        }
    });
    portalParticles = [];
    
    leftPortalParticles.forEach(particle => {
        if (particle.element && particle.element.parentNode) {
            particle.element.remove();
        }
    });
    leftPortalParticles = [];
    
    // 주사위들 제거
    diceArray.forEach(dice => {
        if (dice.element && dice.element.parentNode) {
            dice.element.remove();
        }
    });
    diceArray = [];
    
    // 데미지 인디케이터들 제거
    damageIndicators.forEach(indicator => {
        if (indicator.element && indicator.element.parentNode) {
            indicator.element.remove();
        }
    });
    damageIndicators = [];
    
    // 포털 메시지 제거
    removePortalMessage();
    
    // 통계 초기화
    diceShot = 0;
    totalDamage = 0;
}

// 맵 요소들 생성 함수
function createMapElements(mapData) {
    // 구름은 모든 맵에 생성
    createClouds();
    
    // 맵별 요소 생성
    if (mapData.hasEnemies) {
        createTrainingDummy();
    }
    
    if (mapData.hasTutorialSigns) {
        createTutorialSigns();
    }
    
    // 포털 생성
    if (mapData.portals.right) {
        createMapPortal('right', mapData.portals.right);
    }
    
    if (mapData.portals.left) {
        createMapPortal('left', mapData.portals.left);
    }
}

// 포털 생성 함수 수정 (방향과 목적지를 받도록)
function createMapPortal(direction = 'right', targetMap = null) {
    if (!targetMap) return;
    
    let portal, particles;
    
    if (direction === 'right') {
        portal = mapPortal = {
            element: document.createElement('div'),
            x: mapWidth - 150,
            y: screenHeight - groundHeight - 120,
            width: 80,
            height: 120,
            active: true,
            glowIntensity: 0,
            direction: 'right',
            targetMap: targetMap
        };
        particles = portalParticles;
    } else {
        portal = leftPortal = {
            element: document.createElement('div'),
            x: 70, // 맵 좌측
            y: screenHeight - groundHeight - 120,
            width: 80,
            height: 120,
            active: true,
            glowIntensity: 0,
            direction: 'left',
            targetMap: targetMap
        };
        particles = leftPortalParticles;
    }
    
    portal.element.className = `map-portal ${direction}-portal`;
    portal.element.style.left = portal.x + 'px';
    portal.element.style.top = portal.y + 'px';
    
    // 포털 내부 구조
    portal.element.innerHTML = `
        <div class="portal-outer-ring"></div>
        <div class="portal-inner-ring"></div>
        <div class="portal-core"></div>
        <div class="portal-particles"></div>
    `;
    
    gameContainer.appendChild(portal.element);
    
    // 포털별 파티클 생성
    createPortalParticlesForPortal(portal, particles);
}

// 특정 포털용 파티클 생성
function createPortalParticlesForPortal(portal, particleArray) {
    for (let i = 0; i < 15; i++) {
        const particle = {
            element: document.createElement('div'),
            x: portal.x + portal.width/2,
            y: portal.y + portal.height/2,
            angle: (Math.PI * 2 * i) / 15,
            radius: Math.random() * 30 + 20,
            speed: Math.random() * 0.02 + 0.01,
            opacity: Math.random() * 0.8 + 0.2,
            portalRef: portal
        };
        
        particle.element.className = 'portal-particle';
        particle.element.style.opacity = particle.opacity;
        gameContainer.appendChild(particle.element);
        particleArray.push(particle);
    }
}

// 포털 업데이트 함수 수정
function updatePortal() {
    updateSinglePortal(mapPortal, 'showPortalMessage');
    updateSinglePortal(leftPortal, 'showLeftPortalMessage');
}

// 단일 포털 업데이트
function updateSinglePortal(portal, messageFlag) {
    if (!portal) return;
    
    // 카메라 오프셋 적용
    const screenX = portal.x - cameraX;
    portal.element.style.left = screenX + 'px';
    
    // 포털과 플레이어 거리 계산
    const portalCenterX = portal.x + portal.width/2;
    const portalCenterY = portal.y + portal.height/2;
    const playerCenterX = playerX + playerSize/2;
    const playerCenterY = playerY + playerSize/2;
    
    const distance = Math.sqrt(
        Math.pow(portalCenterX - playerCenterX, 2) + 
        Math.pow(portalCenterY - playerCenterY, 2)
    );
    
    // 플레이어가 포털 근처에 있는지 확인 (100px 이내)
    if (distance < 100) {
        if (portal.direction === 'right' && !showPortalMessage) {
            showPortalMessage = true;
            createPortalMessage(portal.direction, portal.targetMap);
        } else if (portal.direction === 'left' && !showLeftPortalMessage) {
            showLeftPortalMessage = true;
            createPortalMessage(portal.direction, portal.targetMap);
        }
        
        portal.glowIntensity = Math.min(1, portal.glowIntensity + 0.02);
    } else {
        if (portal.direction === 'right' && showPortalMessage) {
            showPortalMessage = false;
            removePortalMessage();
        } else if (portal.direction === 'left' && showLeftPortalMessage) {
            showLeftPortalMessage = true;
            removePortalMessage();
        }
        
        portal.glowIntensity = Math.max(0.3, portal.glowIntensity - 0.02);
    }
    
    // 포털 글로우 효과 적용
    portal.element.style.filter = `brightness(${1 + portal.glowIntensity})`;
}

// 포털 메시지 생성 수정
function createPortalMessage(direction = 'right', targetMap = '') {
    if (document.getElementById('portalMessage')) return;
    
    const message = document.createElement('div');
    message.id = 'portalMessage';
    message.className = 'portal-message';
    
    let mapDisplayName = '';
    if (targetMap === 'tutorial') {
        mapDisplayName = '튜토리얼 맵';
    } else if (targetMap === 'stage1') {
        mapDisplayName = '스테이지 1';
    }
    
    message.innerHTML = `
        <div class="message-content">
            <div class="message-icon">🌀</div>
            <div class="message-text">Z키를 눌러 ${mapDisplayName}으로 이동</div>
        </div>
    `;
    
    gameContainer.appendChild(message);
}

// 포털 파티클 업데이트 수정
function updatePortalParticles() {
    updateParticleArray(portalParticles);
    updateParticleArray(leftPortalParticles);
}

function updateParticleArray(particleArray) {
    particleArray.forEach(particle => {
        // 원형 궤도로 회전
        particle.angle += particle.speed;
        
        const portal = particle.portalRef;
        const centerX = portal.x + portal.width/2;
        const centerY = portal.y + portal.height/2;
        
        particle.x = centerX + Math.cos(particle.angle) * particle.radius;
        particle.y = centerY + Math.sin(particle.angle) * particle.radius;
        
        // 카메라 오프셋 적용
        const screenX = particle.x - cameraX;
        particle.element.style.left = screenX + 'px';
        particle.element.style.top = particle.y + 'px';
        
        // 투명도 애니메이션
        particle.opacity = 0.2 + Math.sin(particle.angle * 3) * 0.3;
        particle.element.style.opacity = Math.max(0.1, particle.opacity);
    });
}

// 다음 맵으로 이동 함수 수정 (상세한 로그 포함)
function moveToNextMap() {
    console.log('=== moveToNextMap 함수 시작 ===');
    console.log('showPortalMessage:', showPortalMessage);
    console.log('showLeftPortalMessage:', showLeftPortalMessage);
    console.log('mapPortal:', mapPortal);
    console.log('leftPortal:', leftPortal);
    
    let targetMap = null;
    
    // 어느 포털을 사용하는지 확인
    if (showPortalMessage && mapPortal) {
        targetMap = mapPortal.targetMap;
        console.log('우측 포털 사용, targetMap:', targetMap);
    } else if (showLeftPortalMessage && leftPortal) {
        targetMap = leftPortal.targetMap;
        console.log('좌측 포털 사용, targetMap:', targetMap);
    }
    
    console.log('최종 targetMap:', targetMap);
    
    if (!targetMap) {
        console.log('targetMap이 없어서 함수 종료');
        return;
    }
    
    // 포털 진입 효과
    const portalEffect = document.createElement('div');
    portalEffect.className = 'portal-transition-effect';
    document.body.appendChild(portalEffect);
    
    console.log(`${targetMap} 맵으로 이동 시작!`);
    
    // targetMap을 setTimeout 안에서 사용할 수 있도록 저장
    const nextMap = targetMap;
    console.log('nextMap 변수에 저장:', nextMap);
    
    setTimeout(() => {
    console.log('setTimeout 실행, nextMap:', nextMap);
    // 맵 전환 (포털을 통해 이동했다는 것을 표시)
    initializeMap(nextMap, true);
    portalEffect.remove();
        
        // 메시지 플래그 초기화
        showPortalMessage = false;
        showLeftPortalMessage = false;
        console.log('맵 전환 완료');
    }, 1000);
}

// startGame 함수 수정
function startGame() {
    // 튜토리얼 맵으로 시작
    initializeMap('tutorial');
    gameLoop();
}
// 튜토리얼 사인 생성 함수
function createTutorialSigns() {
    const tutorials = [
        {
            x: 400,
            y: screenHeight - groundHeight - 180,
            text: "A/D키로\n좌우 이동",
            arrow: "←→"
        },
        {
            x: 900,
            y: screenHeight - groundHeight - 180,
            text: "스페이스바로\n점프",
            arrow: "↑"
        },
        {
            x: 1400,
            y: screenHeight - groundHeight - 180,
            text: "화살표키로\n주사위 발사",
            arrow: "🎲"
        },
        {
            x: mapWidth - 695,
            y: screenHeight - groundHeight - 200,
            text: "허수아비를\n공격해보세요!",
            arrow: "🎯"
        }
    ];
    
    tutorials.forEach((tutorial, index) => {
        // 사인 생성
        const sign = {
            element: document.createElement('div'),
            x: tutorial.x,
            y: tutorial.y,
            id: `tutorial-${index}`
        };
        
        sign.element.className = 'tutorial-sign';
        sign.element.innerHTML = tutorial.text.replace('\n', '<br>');
        sign.element.style.left = tutorial.x + 'px';
        sign.element.style.top = tutorial.y + 'px';
        
        gameContainer.appendChild(sign.element);
        tutorialSigns.push(sign);
        
        // 화살표 생성
        const arrow = {
            element: document.createElement('div'),
            x: tutorial.x,
            y: tutorial.y - 40,
            signIndex: index
        };
        
        arrow.element.className = 'tutorial-arrow';
        arrow.element.textContent = tutorial.arrow;
        arrow.element.style.left = (tutorial.x + 100) + 'px';
        arrow.element.style.top = (tutorial.y - 40) + 'px';
        
        gameContainer.appendChild(arrow.element);
        tutorialSigns.push(arrow);
    });
}

// 튜토리얼 업데이트 함수
function updateTutorialSigns() {
    tutorialSigns.forEach(sign => {
        // 카메라 오프셋 적용
        const screenX = sign.x - cameraX;
        sign.element.style.left = screenX + 'px';
    });
}
    // 물리 엔진
    function updatePhysics() {
        // 중력 적용
        velocityY += gravity;
        
        // 공기 저항
if (!isOnGround) {
    velocityX *= airResistance;
} else {
    // 땅에서의 마찰
    velocityX *= friction;
}
        
        // 최대 속도 제한
        const maxVelocityX = moveSpeed;
        const maxVelocityY = 25;
        
        if (velocityX > maxVelocityX) velocityX = maxVelocityX;
        if (velocityX < -maxVelocityX) velocityX = -maxVelocityX;
        if (velocityY > maxVelocityY) velocityY = maxVelocityY;
        
        // 위치 업데이트
        playerX += velocityX;
        playerY += velocityY;
        
        // 경계 충돌 검사
        checkCollisions();
    }
    
    // 충돌 검사
    function checkCollisions() {
        // 좌우 벽 충돌 (맵 크기 기준)
if (playerX < 0) {
    playerX = 0;
    velocityX = 0;
}
if (playerX > mapWidth - playerSize) {
    playerX = mapWidth - playerSize;
    velocityX = 0;
}
        
        // 땅 충돌
        // 땅 충돌 (캐릭터 발이 땅 표면에 정확히 닿도록)
const groundSurfaceY = screenHeight - groundHeight; // 땅의 표면 위치
const groundY = groundSurfaceY - playerSize; // 캐릭터가 땅 위에 서는 위치
if (playerY >= groundY) {
    playerY = groundY;
    velocityY = 0;
    isOnGround = true;
} else {
    isOnGround = false;
}
        
        // 천장 충돌
        if (playerY < 0) {
            playerY = 0;
            velocityY = 0;
        }
    }
    
    // 플레이어 위치 업데이트
function updatePlayerPosition() {
    updateCamera();
    
    // 카메라 오프셋을 적용한 화면상 위치
    const screenX = playerX - cameraX;
    
    player.style.left = Math.round(screenX) + 'px';
    player.style.top = Math.round(playerY) + 'px';
    coordinates.textContent = `X: ${Math.round(playerX)}, Y: ${Math.round(playerY)} | Camera: ${Math.round(cameraX)}`;
}

// 카메라 업데이트 함수 (부드러운 전환)
function updateCamera() {
    const followPosition = screenWidth * 1/3; // 600px
    const leftBoundary = followPosition; // 600px
const rightBoundary = mapWidth - (screenWidth - followPosition); // 2400px
    
    let targetCameraX;
    
    if (playerX < leftBoundary) {
        // 좌측 구간: 카메라 고정
        targetCameraX = 0;
    } else if (playerX > rightBoundary) {
        // 우측 구간: 카메라 고정
        targetCameraX = mapWidth - screenWidth;
    } else {
        // 중간 구간: 캐릭터 따라가기
        targetCameraX = playerX - followPosition;
    }
    
    // 부드러운 카메라 이동 (선택사항)
    // cameraX += (targetCameraX - cameraX) * 0.1;
    
    // 즉시 이동
    cameraX = targetCameraX;
}
    
    // 키보드 이벤트 처리
    document.addEventListener('keydown', function(event) {
        console.log('Key pressed:', event.key, event.code); // 디버깅용
        
        switch(event.key.toLowerCase()) {
            case 'a':
                keys.left = true;
                event.preventDefault();
                break;
            case 'd':
                keys.right = true;
                event.preventDefault();
                break;

case 'z':
    if (showPortalMessage || showLeftPortalMessage) {
        moveToNextMap();
    }
    event.preventDefault();
    break;
            case ' ': //스페이스 바
                keys.jump = true;
                event.preventDefault();
                break;
            case 's':
                keys.shoot = true;
                event.preventDefault();
                break;
            case 'arrowleft':
                keys.arrowLeft = true;
                event.preventDefault();
                break;
            case 'arrowright':
                keys.arrowRight = true;
                event.preventDefault();
                break;
            case 'arrowup':
                keys.arrowUp = true;
                event.preventDefault();
                break;
            case 'arrowdown':
                keys.arrowDown = true;
                event.preventDefault();
                break;
        }
    });
    
    document.addEventListener('keyup', function(event) {
        switch(event.key.toLowerCase()) {
            case 'a':
                keys.left = false;
                event.preventDefault();
                break;
            case 'd':
                keys.right = false;
                event.preventDefault();
                break;
            case ' ': // 스페이스바
                keys.jump = false;
                event.preventDefault();
                break;
            case 's':
                keys.shoot = false;
                event.preventDefault();
                break;
            case 'arrowleft':
                keys.arrowLeft = false;
                event.preventDefault();
                break;
            case 'arrowright':
                keys.arrowRight = false;
                event.preventDefault();
                break;
            case 'arrowup':
                keys.arrowUp = false;
                event.preventDefault();
                break;
            case 'arrowdown':
                keys.arrowDown = false;
                event.preventDefault();
                break;
        }
    });
    
    // 구글 시트 연동 함수들
    function loadPosition() {
        google.script.run
            .withSuccessHandler(function(data) {
                playerX = data.playerX;
                playerY = data.playerY;
                moveSpeed = data.moveSpeed;
                jumpPower = data.jumpPower;
                gravity = data.gravity;
                
                // 속도 초기화
                velocityX = 0;
                velocityY = 0;
                
                updatePlayerPosition();
                alert('데이터를 불러왔습니다!');
            })
            .withFailureHandler(function(error) {
                alert('데이터를 불러오는데 실패했습니다: ' + error);
            })
            .getGameData();
    }
    
    function savePosition() {
        google.script.run
            .withSuccessHandler(function(result) {
                alert('위치가 저장되었습니다!');
            })
            .withFailureHandler(function(error) {
                alert('저장에 실패했습니다: ' + error);
            })
            .saveGameData(Math.round(playerX), Math.round(playerY));
    }
    
    function resetPosition() {
        google.script.run
            .withSuccessHandler(function(result) {
                playerX = 100;
                playerY = screenHeight - groundHeight - playerSize; // 땅 표면 바로 위
                velocityX = 0;
                velocityY = 0;
                diceShot = 0;
                totalDamage = 0;
                
                // 모든 주사위 제거
                diceArray.forEach(dice => dice.element.remove());
                diceArray = [];
                
                updatePlayerPosition();
                alert('게임이 초기화되었습니다!');
            })
            .withFailureHandler(function(error) {
                alert('초기화에 실패했습니다: ' + error);
            })
            .resetGame();
    }

    // 포털 생성 함수 수정 (방향과 목적지를 받도록)
function createMapPortal(direction = 'right', targetMap = null) {
    if (!targetMap) return;
    
    let portal, particles;
    
    if (direction === 'right') {
        portal = mapPortal = {
            element: document.createElement('div'),
            x: mapWidth - 150,
            y: screenHeight - groundHeight - 120,
            width: 80,
            height: 120,
            active: true,
            glowIntensity: 0,
            direction: 'right',
            targetMap: targetMap
        };
        particles = portalParticles;
    } else {
        portal = leftPortal = {
            element: document.createElement('div'),
            x: 70, // 맵 좌측
            y: screenHeight - groundHeight - 120,
            width: 80,
            height: 120,
            active: true,
            glowIntensity: 0,
            direction: 'left',
            targetMap: targetMap
        };
        particles = leftPortalParticles;
    }
    
    portal.element.className = `map-portal ${direction}-portal`;
    portal.element.style.left = portal.x + 'px';
    portal.element.style.top = portal.y + 'px';
    
    // 포털 내부 구조
    portal.element.innerHTML = `
        <div class="portal-outer-ring"></div>
        <div class="portal-inner-ring"></div>
        <div class="portal-core"></div>
        <div class="portal-particles"></div>
    `;
    
    gameContainer.appendChild(portal.element);
    
    // 포털별 파티클 생성
    createPortalParticlesForPortal(portal, particles);
}

// 특정 포털용 파티클 생성
function createPortalParticlesForPortal(portal, particleArray) {
    for (let i = 0; i < 15; i++) {
        const particle = {
            element: document.createElement('div'),
            x: portal.x + portal.width/2,
            y: portal.y + portal.height/2,
            angle: (Math.PI * 2 * i) / 15,
            radius: Math.random() * 30 + 20,
            speed: Math.random() * 0.02 + 0.01,
            opacity: Math.random() * 0.8 + 0.2,
            portalRef: portal
        };
        
        particle.element.className = 'portal-particle';
        particle.element.style.opacity = particle.opacity;
        gameContainer.appendChild(particle.element);
        particleArray.push(particle);
    }
}

// 포털 메시지 생성
function createPortalMessage() {
    if (document.getElementById('portalMessage')) return;
    
    const message = document.createElement('div');
    message.id = 'portalMessage';
    message.className = 'portal-message';
    message.innerHTML = `
        <div class="message-content">
            <div class="message-icon">🌀</div>
            <div class="message-text">Z키를 눌러 다음 맵으로 이동</div>
        </div>
    `;
    
    gameContainer.appendChild(message);
}

// 포털 메시지 제거
function removePortalMessage() {
    const message = document.getElementById('portalMessage');
    if (message) {
        message.remove();
    }
}

// 포털 업데이트 함수 수정
function updatePortal() {
    updateSinglePortal(mapPortal, 'showPortalMessage');
    updateSinglePortal(leftPortal, 'showLeftPortalMessage');
}

// 단일 포털 업데이트
function updateSinglePortal(portal, messageFlag) {
    if (!portal) return;
    
    // 카메라 오프셋 적용
    const screenX = portal.x - cameraX;
    portal.element.style.left = screenX + 'px';
    
    // 포털과 플레이어 거리 계산
    const portalCenterX = portal.x + portal.width/2;
    const portalCenterY = portal.y + portal.height/2;
    const playerCenterX = playerX + playerSize/2;
    const playerCenterY = playerY + playerSize/2;
    
    const distance = Math.sqrt(
        Math.pow(portalCenterX - playerCenterX, 2) + 
        Math.pow(portalCenterY - playerCenterY, 2)
    );
    
    // 플레이어가 포털 근처에 있는지 확인 (100px 이내)
    if (distance < 100) {
        if (portal.direction === 'right' && !showPortalMessage) {
            showPortalMessage = true;
            createPortalMessage(portal.direction, portal.targetMap);
        } else if (portal.direction === 'left' && !showLeftPortalMessage) {
            showLeftPortalMessage = true;
            createPortalMessage(portal.direction, portal.targetMap);
        }
        
        portal.glowIntensity = Math.min(1, portal.glowIntensity + 0.02);
    } else {
        if (portal.direction === 'right' && showPortalMessage) {
            showPortalMessage = false;
            removePortalMessage();
        } else if (portal.direction === 'left' && showLeftPortalMessage) {
            showLeftPortalMessage = false;
            removePortalMessage();
        }
        
        portal.glowIntensity = Math.max(0.3, portal.glowIntensity - 0.02);
    }
    
    // 포털 글로우 효과 적용
    portal.element.style.filter = `brightness(${1 + portal.glowIntensity})`;
}

// 포털 파티클 업데이트
function updatePortalParticles() {
    portalParticles.forEach(particle => {
        // 원형 궤도로 회전
        particle.angle += particle.speed;
        
        const centerX = mapPortal.x + mapPortal.width/2;
        const centerY = mapPortal.y + mapPortal.height/2;
        
        particle.x = centerX + Math.cos(particle.angle) * particle.radius;
        particle.y = centerY + Math.sin(particle.angle) * particle.radius;
        
        // 카메라 오프셋 적용
        const screenX = particle.x - cameraX;
        particle.element.style.left = screenX + 'px';
        particle.element.style.top = particle.y + 'px';
        
        // 투명도 애니메이션
        particle.opacity = 0.2 + Math.sin(particle.angle * 3) * 0.3;
        particle.element.style.opacity = Math.max(0.1, particle.opacity);
    });
}    
    // startGame 함수 수정
function startGame() {
    // 튜토리얼 맵으로 시작
    initializeMap('tutorial');
    gameLoop();
}
    
    // 페이지 로드 시 초기화
    window.onload = function() {
        // 게임 설정 로드
        google.script.run
            .withSuccessHandler(function(data) {
                if (data) {
                    moveSpeed = data.moveSpeed || moveSpeed;
                    jumpPower = data.jumpPower || jumpPower;
                    gravity = data.gravity || gravity;
                    bulletSpeed = data.bulletSpeed || bulletSpeed;
                    fireRate = data.fireRate || fireRate;
                }
                startGame();
            })
            .withFailureHandler(function(error) {
                console.log('설정을 불러오는데 실패했지만 기본값으로 시작합니다.');
                startGame();
            })
            .getGameSettings();
    };
</script>
