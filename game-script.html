<script>
    // ê²Œì„ ìš”ì†Œë“¤
    let player = document.getElementById('player');
    let gameContainer = document.getElementById('gameContainer');
    let coordinates = document.getElementById('coordinates');
    let gameStats = document.getElementById('gameStats');
    
    // ê²Œì„ ì„¤ì •
// í™”ë©´ í¬ê¸° (ë³´ì´ëŠ” í™”ë©´)
const screenWidth = 1800;
const screenHeight = 900;

// ì‹¤ì œ ë§µ í¬ê¸° (ê°€ìƒì˜ ë§µ, 2ë°°)
const mapWidth = 3600;
const mapHeight = 900;

// ì¹´ë©”ë¼ ì˜¤í”„ì…‹
let cameraX = 0;
    const playerSize = 64;
    const groundHeight = 90;
    
    // í”Œë ˆì´ì–´ ìƒíƒœ
    let playerX = 100;
    let playerY = screenHeight - groundHeight - playerSize;
    let velocityX = 0;
    let velocityY = 0;
    
    // ê²Œì„ ì„¤ì • (êµ¬ê¸€ ì‹œíŠ¸ì—ì„œ ê°€ì ¸ì˜¬ ê°’ë“¤)
    let moveSpeed = 7;
    let jumpPower = 15;
    let gravity = 0.6;
    let friction = 0.8;
    let airResistance = 0.95;
    let bulletSpeed = 10;
    let fireRate = 300; // ë°€ë¦¬ì´ˆ
    
    // í”Œë ˆì´ì–´ ì²´ë ¥ ê´€ë ¨ ë³€ìˆ˜
let playerMaxHp = 100;
let playerCurrentHp = 100;
let isInvulnerable = false;
let invulnerabilityTime = 0;
let invulnerabilityDuration = 120; // 2ì´ˆ (60fps ê¸°ì¤€)
    // ì£¼ì‚¬ìœ„ ê´€ë ¨ ë³€ìˆ˜
    let diceArray = [];
    let diceShot = 0;
    let totalDamage = 0;
    let lastFireTime = 0;

    //êµ¬ë¦„ ê´€ë ¨ ë³€ìˆ˜
    let clouds = [];

    //íŠœí† ë¦¬ì–¼ ë³€ìˆ˜
    let tutorialSigns = [];
// í¬í„¸ ê´€ë ¨ ë³€ìˆ˜ë“¤
let mapPortal = null;
let leftPortal = null;
let portalParticles = [];
let leftPortalParticles = [];
let showPortalMessage = false;
let showLeftPortalMessage = false;

    // ì  ê´€ë ¨ ë³€ìˆ˜ (ìƒˆë¡œ ì¶”ê°€)
    let enemies = [];
    let damageIndicators = [];
    
    // ì…ë ¥ ìƒíƒœ
    let keys = {
    left: false,
    right: false,
    jump: false,
    shoot: false,
    arrowLeft: false,
    arrowRight: false,
    arrowUp: false,
    arrowDown: false
};

// ì¸ë²¤í† ë¦¬ ê´€ë ¨ ë³€ìˆ˜
let inventoryOpen = false;
let inventory = {
    diceCollected: 0,
    maxSlots: 18
};
    
    let isOnGround = false;
    //ê²Œì„ ë£¨í”„
function gameLoop() {
    handleInput();
    updatePhysics();
    updateDice();
    updateEnemies();
    updateDamageIndicators();  // monsters.htmlì— ìˆëŠ” í•¨ìˆ˜ í˜¸ì¶œ
    checkDiceEnemyCollisions();
    updatePlayerInvulnerability(); // ìƒˆë¡œ ì¶”ê°€
    updatePlayerPosition();
    updateTutorialSigns();
    updateClouds();
    updatePortal();           
    updatePortalParticles();
    checkPlayerEnemyCollisions();  
    updateUI();
    requestAnimationFrame(gameLoop);
}
    //ì…ë ¥ ì²˜ë¦¬
    function handleInput() {
    // ì¢Œìš° ì´ë™ (ë•…ì—ì„œ ë” ë¹ ë¥´ê²Œ)
    if (keys.left) {
        if (isOnGround) {
            velocityX -= moveSpeed * 1.0;
        } else {
            velocityX -= moveSpeed * 0.1;
        }
    }
    if (keys.right) {
        if (isOnGround) {
            velocityX += moveSpeed * 0.15;
        } else {
            velocityX += moveSpeed * 0.1;
        }
    }
    
    // ì í”„ (ë•…ì— ìˆì„ ë•Œë§Œ)
    if (keys.jump && isOnGround) {
        velocityY = -jumpPower;
        isOnGround = false;
    }
    
    // ì£¼ì‚¬ìœ„ ë°œì‚¬ (Sí‚¤)
    if (keys.shoot) {
        fireDice(); // ê¸°ë³¸ ìš°ì¸¡ ë°œì‚¬
    }
    
    // í™”ì‚´í‘œí‚¤ë¡œ ë°©í–¥ ë°œì‚¬
    if (keys.arrowLeft) {
        fireDice(-1, 0); // ì™¼ìª½
    }
    if (keys.arrowRight) {
        fireDice(1, 0); // ì˜¤ë¥¸ìª½
    }
    if (keys.arrowUp) {
        fireDice(0, -1); // ìœ„ìª½
    }
    if (keys.arrowDown) {
        fireDice(0, 1); // ì•„ë˜ìª½
    }
}

    // ì£¼ì‚¬ìœ„ ëˆˆ ìƒì„± í•¨ìˆ˜ - ê°œì„ ëœ ë²„ì „
    function createDiceFace(value) {
        let dotsHTML = '';
        
        // ì£¼ì‚¬ìœ„ ëˆˆì— ë”°ë¼ ì  ìƒì„±
        for (let i = 0; i < value; i++) {
            dotsHTML += '<div class="dice-dot"></div>';
        }
        
        return dotsHTML;
    }

    // ì£¼ì‚¬ìœ„ ë°œì‚¬ í•¨ìˆ˜
    function fireDice(directionX = 1, directionY = 0) {
    const currentTime = Date.now();
    if (currentTime - lastFireTime < fireRate) return;
    
    lastFireTime = currentTime;
    diceShot++;




    // ì£¼ì‚¬ìœ„ ìƒì„±
    const dice = {
        element: document.createElement('div'),
        x: playerX + playerSize / 2,
        y: playerY + playerSize / 2,
        velocityX: bulletSpeed * directionX,
        velocityY: bulletSpeed * directionY,
        value: Math.floor(Math.random() * 6) + 1,
        life: 300,
        rollCounter: 0
    };
        
        // ì£¼ì‚¬ìœ„ ìš”ì†Œ ì„¤ì •
        dice.element.className = `dice dice-face-${dice.value}`;
        dice.element.innerHTML = createDiceFace(dice.value);
        dice.element.style.left = dice.x + 'px';
        dice.element.style.top = dice.y + 'px';
        
        gameContainer.appendChild(dice.element);
        diceArray.push(dice);
        
        totalDamage += dice.value;
    }
    

    

    

    

    // ì£¼ì‚¬ìœ„ì™€ ì  ì¶©ëŒ ê²€ì‚¬
    function checkDiceEnemyCollisions() {
        for (let i = diceArray.length - 1; i >= 0; i--) {
            const dice = diceArray[i];
            
            for (let j = 0; j < enemies.length; j++) {
                const enemy = enemies[j];
                
                if (dice.x < enemy.x + enemy.width &&
                    dice.x + 25 > enemy.x &&
                    dice.y < enemy.y + enemy.height &&
                    dice.y + 25 > enemy.y) {
                    
                    enemy.currentHp -= dice.value;
                    if (enemy.currentHp < 0) enemy.currentHp = 0;
                    
                    createDamageIndicator(enemy.x, enemy.y, enemy.width, dice.value);
                    
                    dice.element.remove();
                    diceArray.splice(i, 1);
                    break;
                }
            }
        }
    }
    // ì£¼ì‚¬ìœ„ ì—…ë°ì´íŠ¸
    function updateDice() {
        for (let i = diceArray.length - 1; i >= 0; i--) {
            const dice = diceArray[i];
            
            // ì£¼ì‚¬ìœ„ ì´ë™
            dice.x += dice.velocityX;
            dice.y += dice.velocityY;
            
            // ì£¼ì‚¬ìœ„ ëˆˆ ëœë¤ ë³€ê²½ (ë” ì•ˆì •ì ìœ¼ë¡œ)
            dice.rollCounter++;
            if (dice.rollCounter % 40 === 0) { // 20í”„ë ˆì„ë§ˆë‹¤ ë³€ê²½ (ë” ì²œì²œíˆ)
                const oldValue = dice.value;
                dice.value = Math.floor(Math.random() * 6) + 1;
                
                // ê°’ì´ ë°”ë€Œì—ˆì„ ë•Œë§Œ ì—…ë°ì´íŠ¸
                if (oldValue !== dice.value) {
                    dice.element.className = `dice dice-face-${dice.value}`;
                    dice.element.innerHTML = createDiceFace(dice.value);
                    
                    // ì´ ë°ë¯¸ì§€ ì—…ë°ì´íŠ¸ (ì´ì „ ê°’ ë¹¼ê³  ìƒˆ ê°’ ë”í•˜ê¸°)
                    totalDamage = totalDamage - oldValue + dice.value;
                }
            }
            
            // ìœ„ì¹˜ ì—…ë°ì´íŠ¸ (ì¹´ë©”ë¼ ì˜¤í”„ì…‹ ì ìš©)
const screenX = dice.x - cameraX;
dice.element.style.left = screenX + 'px';
dice.element.style.top = dice.y + 'px';
            
            // ìˆ˜ëª… ê°ì†Œ
            dice.life--;
            
            // ë§µ ë°–ìœ¼ë¡œ ë‚˜ê°€ê±°ë‚˜ ìˆ˜ëª…ì´ ë‹¤í•˜ë©´ ì œê±°
if (dice.x > mapWidth || dice.y > screenHeight || dice.life <= 0 || dice.x < 0) {
                dice.element.remove();
                diceArray.splice(i, 1);
            }
        }
    }
    
    
    // UI ì—…ë°ì´íŠ¸
function updateUI() {
    gameStats.textContent = `ì£¼ì‚¬ìœ„: ${diceShot}ë°œ | ì´ ë°ë¯¸ì§€: ${totalDamage}`;
    updatePlayerHpBar();
    updateInventoryDisplay(); // ì´ ì¤„ ì¶”ê°€
}

// ì¸ë²¤í† ë¦¬ UI ìƒì„± (ë¨¼ì € ì •ì˜)
function createInventoryUI() {
    const inventoryElement = document.createElement('div');
    inventoryElement.id = 'inventory';
    inventoryElement.innerHTML = `
    <!-- ìœ ë¦¬êµ¬ìŠ¬ (ê°€ë°© ë°–ì— ë…ë¦½ì ìœ¼ë¡œ) -->
    <div class="orb-slot-container">
        <div class="glass-orb" id="orb-slot">
            <!-- ìœ ë¦¬êµ¬ìŠ¬ ì•ˆì˜ ì •ìœ¡ë©´ì²´ ì „ê°œë„ ìŠ¬ë¡¯ë“¤ -->
            <div class="cube-net-container">
                <div class="cube-slot center" id="cube-slot-center"></div>
                <div class="cube-slot top" id="cube-slot-top"></div>
                <div class="cube-slot bottom" id="cube-slot-bottom"></div>
                <div class="cube-slot left" id="cube-slot-left"></div>
                <div class="cube-slot right" id="cube-slot-right"></div>
                <div class="cube-slot far-bottom" id="cube-slot-far-bottom"></div>
            </div>
        </div>
    </div>
    
    <!-- ê°€ë°© ì»¨í…Œì´ë„ˆ -->
    <div class="inventory-content">
        <div class="inventory-bottom-section">
            <div class="inventory-bag">
                <div class="bag-section">
                    <div class="inventory-grid" id="inventory-grid-1">
                        <!-- ì²« ë²ˆì§¸ ê°€ë°© êµ¬ì—­ -->
                    </div>
                </div>
            </div>
            <div class="inventory-bag">
                <div class="bag-section">
                    <div class="inventory-grid" id="inventory-grid-2">
                        <!-- ë‘ ë²ˆì§¸ ê°€ë°© êµ¬ì—­ -->
                    </div>
                </div>
            </div>
        </div>
    </div>
`;
    
    gameContainer.appendChild(inventoryElement);
    
    // ì²« ë²ˆì§¸ ê°€ë°© êµ¬ì—­ ìŠ¬ë¡¯ ìƒì„±
    const grid1 = document.getElementById('inventory-grid-1');
    for (let i = 0; i < 9; i++) {
        const slot = document.createElement('div');
        slot.className = 'inventory-slot';
        slot.id = `inventory-slot-${i}`;
        grid1.appendChild(slot);
    }
    
    // ë‘ ë²ˆì§¸ ê°€ë°© êµ¬ì—­ ìŠ¬ë¡¯ ìƒì„±
    const grid2 = document.getElementById('inventory-grid-2');
    for (let i = 9; i < 18; i++) {
        const slot = document.createElement('div');
        slot.className = 'inventory-slot';
        slot.id = `inventory-slot-${i}`;
        grid2.appendChild(slot);
    }
}

// ì¸ë²¤í† ë¦¬ í† ê¸€ í•¨ìˆ˜
function toggleInventory() {
    const inventoryElement = document.getElementById('inventory');
    
    if (inventoryOpen) {
        inventoryElement.style.display = 'none';
        inventoryOpen = false;
    } else {
        if (!inventoryElement) {
            createInventoryUI();
        }
        document.getElementById('inventory').style.display = 'block';
        updateInventoryDisplay();
        inventoryOpen = true;
    }
}

// ì¸ë²¤í† ë¦¬ í‘œì‹œ ì—…ë°ì´íŠ¸
function updateInventoryDisplay() {
    if (!inventoryOpen) return;
    
    // ì˜ˆì‹œ ì•„ì´í…œ í‘œì‹œ (ì£¼ì‚¬ìœ„)
    if (diceShot > 0) {
        const firstSlot = document.getElementById('inventory-slot-0');
        if (firstSlot) {
            firstSlot.className = 'inventory-slot occupied';
            firstSlot.innerHTML = `
                <div class="inventory-item">ğŸ²</div>
                <div class="inventory-item-count">${Math.min(diceShot, 99)}</div>
            `;
        }
    }
    
    // ìœ ë¦¬êµ¬ìŠ¬ ìŠ¬ë¡¯ ì˜ˆì‹œ (ì´ ë°ë¯¸ì§€ê°€ 50 ì´ìƒì¼ ë•Œ)
    if (totalDamage >= 50) {
        const orbSlot = document.getElementById('orb-slot');
        const orbItem = document.getElementById('orb-item');
        if (orbSlot && orbItem) {
            orbSlot.className = 'glass-orb occupied';
            orbItem.style.display = 'block';
            orbItem.textContent = 'ğŸ’';
        }
    }
    
    // ì‹­ìê°€ ìŠ¬ë¡¯ ì˜ˆì‹œ (ì£¼ì‚¬ìœ„ 10ë°œ ì´ìƒ ë°œì‚¬ì‹œ)
    if (diceShot >= 10) {
        const centerSlot = document.getElementById('cross-slot-center');
        if (centerSlot) {
            centerSlot.innerHTML = 'âš”ï¸';
            centerSlot.style.fontSize = '16px';
        }
    }
}

// ì¸ë²¤í† ë¦¬ í‘œì‹œ ì—…ë°ì´íŠ¸
function updateInventoryDisplay() {
    if (!inventoryOpen) return;
    
    // ì˜ˆì‹œ ì•„ì´í…œ í‘œì‹œ (ì£¼ì‚¬ìœ„)
    if (diceShot > 0) {
        const firstSlot = document.getElementById('inventory-slot-0');
        if (firstSlot) {
            firstSlot.className = 'inventory-slot occupied';
            firstSlot.innerHTML = `
                <div class="inventory-item">ğŸ²</div>
                <div class="inventory-item-count">${Math.min(diceShot, 99)}</div>
            `;
        }
    }
}

// í”Œë ˆì´ì–´ ì²´ë ¥ë°” ì—…ë°ì´íŠ¸
function updatePlayerHpBar() {
    const hpFill = document.querySelector('.player-hp-fill');
    const hpText = document.querySelector('.player-hp-text');
    
    if (hpFill && hpText) {
        const hpPercent = (playerCurrentHp / playerMaxHp) * 100;
        hpFill.style.width = hpPercent + '%';
        hpText.textContent = `${playerCurrentHp}/${playerMaxHp}`;
    }
}

// í”Œë ˆì´ì–´ ë¬´ì  ì‹œê°„ ì²˜ë¦¬
function updatePlayerInvulnerability() {
    if (isInvulnerable) {
        invulnerabilityTime--;
        
        // ë¬´ì  ì‹œê°„ ì¤‘ ê¹œë¹¡ì„ íš¨ê³¼
        if (invulnerabilityTime % 12 < 6) {
            player.classList.add('player-invulnerable');
        } else {
            player.classList.remove('player-invulnerable');
        }
        
        // ë¬´ì  ì‹œê°„ ì¢…ë£Œ
        if (invulnerabilityTime <= 0) {
            isInvulnerable = false;
            player.classList.remove('player-invulnerable');
        }
    }
}

// í”Œë ˆì´ì–´ê°€ ë°ë¯¸ì§€ë¥¼ ë°›ëŠ” í•¨ìˆ˜
function takeDamage(damage) {
    if (isInvulnerable) return; // ë¬´ì  ìƒíƒœë©´ ë°ë¯¸ì§€ ì•ˆë°›ìŒ
    
    playerCurrentHp -= damage;
    if (playerCurrentHp < 0) playerCurrentHp = 0;
    
    // ë°ë¯¸ì§€ í‘œì‹œê¸° ìƒì„±
    createPlayerDamageIndicator(damage);
    
    // ë¬´ì  ìƒíƒœ ì‹œì‘
    isInvulnerable = true;
    invulnerabilityTime = invulnerabilityDuration;
    
    console.log(`í”Œë ˆì´ì–´ê°€ ${damage} ë°ë¯¸ì§€ë¥¼ ë°›ì•˜ìŠµë‹ˆë‹¤! í˜„ì¬ ì²´ë ¥: ${playerCurrentHp}/${playerMaxHp}`);
    
    // í”Œë ˆì´ì–´ê°€ ì£½ì—ˆëŠ”ì§€ í™•ì¸
    if (playerCurrentHp <= 0) {
        console.log("í”Œë ˆì´ì–´ê°€ ì£½ì—ˆìŠµë‹ˆë‹¤!");
        // ì—¬ê¸°ì— ê²Œì„ ì˜¤ë²„ ë¡œì§ ì¶”ê°€ ê°€ëŠ¥
    }
}
    // êµ¬ë¦„ ìƒì„± í•¨ìˆ˜
function createClouds() {
    const cloudTypes = ['cloud-small', 'cloud-medium', 'cloud-large'];
    
    for (let i = 0; i < 8; i++) {
        const cloud = {
            element: document.createElement('div'),
            x: Math.random() * mapWidth,
            y: Math.random() * 200 + 50, // í•˜ëŠ˜ ìœ„ìª½ì—ë§Œ
            type: cloudTypes[Math.floor(Math.random() * cloudTypes.length)]
        };
        
        cloud.element.className = `cloud ${cloud.type}`;
        cloud.element.style.left = cloud.x + 'px';
        cloud.element.style.top = cloud.y + 'px';
        
        gameContainer.appendChild(cloud.element);
        clouds.push(cloud);
    }
}

// êµ¬ë¦„ ìœ„ì¹˜ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
function updateClouds() {
    clouds.forEach(cloud => {
        // ì¹´ë©”ë¼ ì˜¤í”„ì…‹ ì ìš©
        const screenX = cloud.x - cameraX;
        cloud.element.style.left = screenX + 'px';
    });
}
// game-script.htmlì— ì¶”ê°€/ìˆ˜ì •í•  ì½”ë“œ

// ë§µ ê´€ë ¨ ë³€ìˆ˜ ì¶”ê°€ (ê¸°ì¡´ ë³€ìˆ˜ë“¤ê³¼ í•¨ê»˜)
let maps = {
    tutorial: {
        name: 'tutorial',
        hasEnemies: true,
        hasTutorialSigns: true,
        portals: {
            right: 'stage1',
            left: null
        }
    },
    stage1: {
        name: 'stage1',
        hasEnemies: true,
        hasTutorialSigns: false,
        portals: {
            right: 'village',
            left: 'tutorial'
        }
    },
    village: {
        name: 'village',
        hasEnemies: false,
        hasTutorialSigns: false,
        portals: {
            right: null,
            left: 'stage1'
        }
    }
};

// ë§µ ì´ˆê¸°í™” í•¨ìˆ˜
function initializeMap(mapName, fromPortal = false, portalDirection = 'right') {
    currentMap = mapName;
    const mapData = maps[mapName];
    
    // ê¸°ì¡´ ìš”ì†Œë“¤ ì œê±°
    clearMapElements();
    
    // í”Œë ˆì´ì–´ ìœ„ì¹˜ ì´ˆê¸°í™”
if (mapName === 'tutorial') {
    if (fromPortal && portalDirection === 'left') {
        // stage1 ì¢Œì¸¡ í¬í„¸ì—ì„œ ì˜¨ ê²½ìš° ìš°ì¸¡ì— ë°°ì¹˜
        playerX = mapWidth - 300;
    } else {
        playerX = 100;
    }
} else if (mapName === 'stage1') {
    if (fromPortal) {
        if (portalDirection === 'left') {
            // ë§ˆì„ ì¢Œì¸¡ í¬í„¸ì—ì„œ ì˜¨ ê²½ìš° ìš°ì¸¡ì— ë°°ì¹˜
            playerX = mapWidth - 300;
        } else {
            // íŠœí† ë¦¬ì–¼ ìš°ì¸¡ í¬í„¸ì—ì„œ ì˜¨ ê²½ìš° ì¢Œì¸¡ì— ë°°ì¹˜
            playerX = 100;
        }
    } else {
        playerX = 100;
    }
} else if (mapName === 'village') {
    if (fromPortal && portalDirection === 'right') {
        // stage1 ìš°ì¸¡ í¬í„¸ì—ì„œ ì˜¨ ê²½ìš° ì¢Œì¸¡ì— ë°°ì¹˜
        playerX = 100;
    } else {
        playerX = mapWidth - 300;
    }
}
    playerY = screenHeight - groundHeight - playerSize;
    velocityX = 0;
    velocityY = 0;
    
    // ì¹´ë©”ë¼ ìœ„ì¹˜ ì´ˆê¸°í™”
    cameraX = 0;
    
    // ë§µë³„ ìš”ì†Œ ìƒì„±
    createMapElements(mapData);
    
    updatePlayerPosition();
}

// ë§µ ìš”ì†Œë“¤ ì œê±° í•¨ìˆ˜
function clearMapElements() {
    // ì ë“¤ ì œê±°
    enemies.forEach(enemy => {
        if (enemy.element && enemy.element.parentNode) {
            enemy.element.remove();
        }
    });
    enemies = [];
    
    // íŠœí† ë¦¬ì–¼ ì‚¬ì¸ë“¤ ì œê±°
    tutorialSigns.forEach(sign => {
        if (sign.element && sign.element.parentNode) {
            sign.element.remove();
        }
    });
    tutorialSigns = [];
    
    // í¬í„¸ë“¤ ì œê±°
    if (mapPortal && mapPortal.element && mapPortal.element.parentNode) {
        mapPortal.element.remove();
    }
    if (leftPortal && leftPortal.element && leftPortal.element.parentNode) {
        leftPortal.element.remove();
    }
    mapPortal = null;
    leftPortal = null;
    
    // í¬í„¸ íŒŒí‹°í´ë“¤ ì œê±°
    portalParticles.forEach(particle => {
        if (particle.element && particle.element.parentNode) {
            particle.element.remove();
        }
    });
    portalParticles = [];
    
    leftPortalParticles.forEach(particle => {
        if (particle.element && particle.element.parentNode) {
            particle.element.remove();
        }
    });
    leftPortalParticles = [];
    
    // ì£¼ì‚¬ìœ„ë“¤ ì œê±°
    diceArray.forEach(dice => {
        if (dice.element && dice.element.parentNode) {
            dice.element.remove();
        }
    });
    diceArray = [];
    
    // ë°ë¯¸ì§€ ì¸ë””ì¼€ì´í„°ë“¤ ì œê±°
    damageIndicators.forEach(indicator => {
        if (indicator.element && indicator.element.parentNode) {
            indicator.element.remove();
        }
    });
    damageIndicators = [];
    
    // í¬í„¸ ë©”ì‹œì§€ ì œê±°
    removePortalMessage();
    
    // í†µê³„ ì´ˆê¸°í™”
    diceShot = 0;
    totalDamage = 0;
}

// ë§µ ìš”ì†Œë“¤ ìƒì„± í•¨ìˆ˜
function createMapElements(mapData) {
    // êµ¬ë¦„ì€ ëª¨ë“  ë§µì— ìƒì„±
    createClouds();
    
    // ë§µë³„ ìš”ì†Œ ìƒì„±
if (mapData.hasEnemies) {
    if (mapData.name === 'tutorial') {
        createTrainingDummy();
    } else if (mapData.name === 'stage1') {
        createSlime(300, screenHeight - groundHeight - 30);
    }
}
    
    if (mapData.hasTutorialSigns) {
        createTutorialSigns();
    }
    
    // í¬í„¸ ìƒì„±
    if (mapData.portals.right) {
        createMapPortal('right', mapData.portals.right);
    }
    
    if (mapData.portals.left) {
        createMapPortal('left', mapData.portals.left);
    }
    // ë§ˆì„ ë§µì¸ ê²½ìš°
if (mapData.name === 'village') {
    initializeVillage();
}
}

// í¬í„¸ ìƒì„± í•¨ìˆ˜ ìˆ˜ì • (ë°©í–¥ê³¼ ëª©ì ì§€ë¥¼ ë°›ë„ë¡)
function createMapPortal(direction = 'right', targetMap = null) {
    if (!targetMap) return;
    
    let portal, particles;
    
    if (direction === 'right') {
        portal = mapPortal = {
            element: document.createElement('div'),
            x: mapWidth - 150,
            y: screenHeight - groundHeight - 120,
            width: 80,
            height: 120,
            active: true,
            glowIntensity: 0,
            direction: 'right',
            targetMap: targetMap
        };
        particles = portalParticles;
    } else {
        portal = leftPortal = {
            element: document.createElement('div'),
            x: 70, // ë§µ ì¢Œì¸¡
            y: screenHeight - groundHeight - 120,
            width: 80,
            height: 120,
            active: true,
            glowIntensity: 0,
            direction: 'left',
            targetMap: targetMap
        };
        particles = leftPortalParticles;
    }
    
    portal.element.className = `map-portal ${direction}-portal`;
    portal.element.style.left = portal.x + 'px';
    portal.element.style.top = portal.y + 'px';
    
    // í¬í„¸ ë‚´ë¶€ êµ¬ì¡°
    portal.element.innerHTML = `
        <div class="portal-outer-ring"></div>
        <div class="portal-inner-ring"></div>
        <div class="portal-core"></div>
        <div class="portal-particles"></div>
    `;
    
    gameContainer.appendChild(portal.element);
    
    // í¬í„¸ë³„ íŒŒí‹°í´ ìƒì„±
    createPortalParticlesForPortal(portal, particles);
}

// íŠ¹ì • í¬í„¸ìš© íŒŒí‹°í´ ìƒì„±
function createPortalParticlesForPortal(portal, particleArray) {
    for (let i = 0; i < 15; i++) {
        const particle = {
            element: document.createElement('div'),
            x: portal.x + portal.width/2,
            y: portal.y + portal.height/2,
            angle: (Math.PI * 2 * i) / 15,
            radius: Math.random() * 30 + 20,
            speed: Math.random() * 0.02 + 0.01,
            opacity: Math.random() * 0.8 + 0.2,
            portalRef: portal
        };
        
        particle.element.className = 'portal-particle';
        particle.element.style.opacity = particle.opacity;
        gameContainer.appendChild(particle.element);
        particleArray.push(particle);
    }
}

// í¬í„¸ ì—…ë°ì´íŠ¸ í•¨ìˆ˜ ìˆ˜ì •
function updatePortal() {
    updateSinglePortal(mapPortal, 'showPortalMessage');
    updateSinglePortal(leftPortal, 'showLeftPortalMessage');
}

// ë‹¨ì¼ í¬í„¸ ì—…ë°ì´íŠ¸
function updateSinglePortal(portal, messageFlag) {
    if (!portal) return;
    
    // ì¹´ë©”ë¼ ì˜¤í”„ì…‹ ì ìš©
    const screenX = portal.x - cameraX;
    portal.element.style.left = screenX + 'px';
    
    // í¬í„¸ê³¼ í”Œë ˆì´ì–´ ê±°ë¦¬ ê³„ì‚°
    const portalCenterX = portal.x + portal.width/2;
    const portalCenterY = portal.y + portal.height/2;
    const playerCenterX = playerX + playerSize/2;
    const playerCenterY = playerY + playerSize/2;
    
    const distance = Math.sqrt(
        Math.pow(portalCenterX - playerCenterX, 2) + 
        Math.pow(portalCenterY - playerCenterY, 2)
    );
    
    // í”Œë ˆì´ì–´ê°€ í¬í„¸ ê·¼ì²˜ì— ìˆëŠ”ì§€ í™•ì¸ (100px ì´ë‚´)
    if (distance < 100) {
        if (portal.direction === 'right' && !showPortalMessage) {
            showPortalMessage = true;
            createPortalMessage(portal.direction, portal.targetMap);
        } else if (portal.direction === 'left' && !showLeftPortalMessage) {
            showLeftPortalMessage = true;
            createPortalMessage(portal.direction, portal.targetMap);
        }
        
        portal.glowIntensity = Math.min(1, portal.glowIntensity + 0.02);
    } else {
        if (portal.direction === 'right' && showPortalMessage) {
            showPortalMessage = false;
            removePortalMessage();
        } else if (portal.direction === 'left' && showLeftPortalMessage) {
            showLeftPortalMessage = true;
            removePortalMessage();
        }
        
        portal.glowIntensity = Math.max(0.3, portal.glowIntensity - 0.02);
    }
    
    // í¬í„¸ ê¸€ë¡œìš° íš¨ê³¼ ì ìš©
    portal.element.style.filter = `brightness(${1 + portal.glowIntensity})`;
}

// í¬í„¸ ë©”ì‹œì§€ ìƒì„± ìˆ˜ì •
function createPortalMessage(direction = 'right', targetMap = '') {
    if (document.getElementById('portalMessage')) return;
    
    const message = document.createElement('div');
    message.id = 'portalMessage';
    message.className = 'portal-message';
    
    let mapDisplayName = '';
    if (targetMap === 'tutorial') {
        mapDisplayName = 'íŠœí† ë¦¬ì–¼ ë§µ';
    } else if (targetMap === 'stage1') {
        mapDisplayName = 'ìŠ¤í…Œì´ì§€ 1';
    }
    
    message.innerHTML = `
        <div class="message-content">
            <div class="message-icon">ğŸŒ€</div>
            <div class="message-text">Zí‚¤ë¥¼ ëˆŒëŸ¬ ${mapDisplayName}ìœ¼ë¡œ ì´ë™</div>
        </div>
    `;
    
    gameContainer.appendChild(message);
}

// í¬í„¸ íŒŒí‹°í´ ì—…ë°ì´íŠ¸ ìˆ˜ì •
function updatePortalParticles() {
    updateParticleArray(portalParticles);
    updateParticleArray(leftPortalParticles);
}

function updateParticleArray(particleArray) {
    particleArray.forEach(particle => {
        // ì›í˜• ê¶¤ë„ë¡œ íšŒì „
        particle.angle += particle.speed;
        
        const portal = particle.portalRef;
        const centerX = portal.x + portal.width/2;
        const centerY = portal.y + portal.height/2;
        
        particle.x = centerX + Math.cos(particle.angle) * particle.radius;
        particle.y = centerY + Math.sin(particle.angle) * particle.radius;
        
        // ì¹´ë©”ë¼ ì˜¤í”„ì…‹ ì ìš©
        const screenX = particle.x - cameraX;
        particle.element.style.left = screenX + 'px';
        particle.element.style.top = particle.y + 'px';
        
        // íˆ¬ëª…ë„ ì• ë‹ˆë©”ì´ì…˜
        particle.opacity = 0.2 + Math.sin(particle.angle * 3) * 0.3;
        particle.element.style.opacity = Math.max(0.1, particle.opacity);
    });
}

// ë‹¤ìŒ ë§µìœ¼ë¡œ ì´ë™ í•¨ìˆ˜ ìˆ˜ì • (ìƒì„¸í•œ ë¡œê·¸ í¬í•¨)
function moveToNextMap() {
    console.log('=== moveToNextMap í•¨ìˆ˜ ì‹œì‘ ===');
    console.log('showPortalMessage:', showPortalMessage);
    console.log('showLeftPortalMessage:', showLeftPortalMessage);
    console.log('mapPortal:', mapPortal);
    console.log('leftPortal:', leftPortal);
    
    let targetMap = null;
    
    // ì–´ëŠ í¬í„¸ì„ ì‚¬ìš©í•˜ëŠ”ì§€ í™•ì¸
    if (showPortalMessage && mapPortal) {
        targetMap = mapPortal.targetMap;
        console.log('ìš°ì¸¡ í¬í„¸ ì‚¬ìš©, targetMap:', targetMap);
    } else if (showLeftPortalMessage && leftPortal) {
        targetMap = leftPortal.targetMap;
        console.log('ì¢Œì¸¡ í¬í„¸ ì‚¬ìš©, targetMap:', targetMap);
    }
    
    console.log('ìµœì¢… targetMap:', targetMap);
    
    if (!targetMap) {
        console.log('targetMapì´ ì—†ì–´ì„œ í•¨ìˆ˜ ì¢…ë£Œ');
        return;
    }
    
    // í¬í„¸ ì§„ì… íš¨ê³¼
    const portalEffect = document.createElement('div');
    portalEffect.className = 'portal-transition-effect';
    document.body.appendChild(portalEffect);
    
    console.log(`${targetMap} ë§µìœ¼ë¡œ ì´ë™ ì‹œì‘!`);
    
    // targetMapì„ setTimeout ì•ˆì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ ì €ì¥
    const nextMap = targetMap;
    console.log('nextMap ë³€ìˆ˜ì— ì €ì¥:', nextMap);
    
    setTimeout(() => {
    console.log('setTimeout ì‹¤í–‰, nextMap:', nextMap);
    
    // ì–´ëŠ í¬í„¸ì—ì„œ ì™”ëŠ”ì§€ ì •ë³´ ì „ë‹¬
    let portalDirection = 'right'; // ê¸°ë³¸ê°’
    if (showLeftPortalMessage && leftPortal) {
        portalDirection = 'left';
    }
    
    // ë§µ ì „í™˜ (í¬í„¸ ë°©í–¥ ì •ë³´ë„ í•¨ê»˜ ì „ë‹¬)
    initializeMap(nextMap, true, portalDirection);
    portalEffect.remove();
        
    // ë©”ì‹œì§€ í”Œë˜ê·¸ ì´ˆê¸°í™”
    showPortalMessage = false;
    showLeftPortalMessage = false;
    console.log('ë§µ ì „í™˜ ì™„ë£Œ');
}, 1000);
}

// startGame í•¨ìˆ˜ ìˆ˜ì •
function startGame() {
    // íŠœí† ë¦¬ì–¼ ë§µìœ¼ë¡œ ì‹œì‘
    initializeMap('tutorial');
    gameLoop();
}
// íŠœí† ë¦¬ì–¼ ì‚¬ì¸ ìƒì„± í•¨ìˆ˜
function createTutorialSigns() {
    const tutorials = [
        {
            x: 400,
            y: screenHeight - groundHeight - 180,
            text: "A/Dí‚¤ë¡œ\nì¢Œìš° ì´ë™",
            arrow: "â†â†’"
        },
        {
            x: 900,
            y: screenHeight - groundHeight - 180,
            text: "ìŠ¤í˜ì´ìŠ¤ë°”ë¡œ\nì í”„",
            arrow: "â†‘"
        },
        {
            x: 1400,
            y: screenHeight - groundHeight - 180,
            text: "í™”ì‚´í‘œí‚¤ë¡œ\nì£¼ì‚¬ìœ„ ë°œì‚¬",
            arrow: "ğŸ²"
        },
        {
            x: mapWidth - 695,
            y: screenHeight - groundHeight - 200,
            text: "í—ˆìˆ˜ì•„ë¹„ë¥¼\nê³µê²©í•´ë³´ì„¸ìš”!",
            arrow: "ğŸ¯"
        }
    ];
    
    tutorials.forEach((tutorial, index) => {
        // ì‚¬ì¸ ìƒì„±
        const sign = {
            element: document.createElement('div'),
            x: tutorial.x,
            y: tutorial.y,
            id: `tutorial-${index}`
        };
        
        sign.element.className = 'tutorial-sign';
        sign.element.innerHTML = tutorial.text.replace('\n', '<br>');
        sign.element.style.left = tutorial.x + 'px';
        sign.element.style.top = tutorial.y + 'px';
        
        gameContainer.appendChild(sign.element);
        tutorialSigns.push(sign);
        
        // í™”ì‚´í‘œ ìƒì„±
        const arrow = {
            element: document.createElement('div'),
            x: tutorial.x,
            y: tutorial.y - 40,
            signIndex: index
        };
        
        arrow.element.className = 'tutorial-arrow';
        arrow.element.textContent = tutorial.arrow;
        arrow.element.style.left = (tutorial.x + 100) + 'px';
        arrow.element.style.top = (tutorial.y - 40) + 'px';
        
        gameContainer.appendChild(arrow.element);
        tutorialSigns.push(arrow);
    });
}

// íŠœí† ë¦¬ì–¼ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
function updateTutorialSigns() {
    tutorialSigns.forEach(sign => {
        // ì¹´ë©”ë¼ ì˜¤í”„ì…‹ ì ìš©
        const screenX = sign.x - cameraX;
        sign.element.style.left = screenX + 'px';
    });
}
    // ë¬¼ë¦¬ ì—”ì§„
    function updatePhysics() {
        // ì¤‘ë ¥ ì ìš©
        velocityY += gravity;
        
        // ê³µê¸° ì €í•­
if (!isOnGround) {
    velocityX *= airResistance;
} else {
    // ë•…ì—ì„œì˜ ë§ˆì°°
    velocityX *= friction;
}
        
        // ìµœëŒ€ ì†ë„ ì œí•œ
        const maxVelocityX = moveSpeed;
        const maxVelocityY = 25;
        
        if (velocityX > maxVelocityX) velocityX = maxVelocityX;
        if (velocityX < -maxVelocityX) velocityX = -maxVelocityX;
        if (velocityY > maxVelocityY) velocityY = maxVelocityY;
        
        // ìœ„ì¹˜ ì—…ë°ì´íŠ¸
        playerX += velocityX;
        playerY += velocityY;
        
        // ê²½ê³„ ì¶©ëŒ ê²€ì‚¬
        checkCollisions();
    }
    
    // ì¶©ëŒ ê²€ì‚¬
    function checkCollisions() {
        // ì¢Œìš° ë²½ ì¶©ëŒ (ë§µ í¬ê¸° ê¸°ì¤€)
if (playerX < 0) {
    playerX = 0;
    velocityX = 0;
}
if (playerX > mapWidth - playerSize) {
    playerX = mapWidth - playerSize;
    velocityX = 0;
}
        
        // ë•… ì¶©ëŒ
        // ë•… ì¶©ëŒ (ìºë¦­í„° ë°œì´ ë•… í‘œë©´ì— ì •í™•íˆ ë‹¿ë„ë¡)
const groundSurfaceY = screenHeight - groundHeight; // ë•…ì˜ í‘œë©´ ìœ„ì¹˜
const groundY = groundSurfaceY - playerSize; // ìºë¦­í„°ê°€ ë•… ìœ„ì— ì„œëŠ” ìœ„ì¹˜
if (playerY >= groundY) {
    playerY = groundY;
    velocityY = 0;
    isOnGround = true;
} else {
    isOnGround = false;
}
        
        // ì²œì¥ ì¶©ëŒ
        if (playerY < 0) {
            playerY = 0;
            velocityY = 0;
        }
    }
    
    // í”Œë ˆì´ì–´ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
function updatePlayerPosition() {
    updateCamera();
    
    // ì¹´ë©”ë¼ ì˜¤í”„ì…‹ì„ ì ìš©í•œ í™”ë©´ìƒ ìœ„ì¹˜
    const screenX = playerX - cameraX;
    
    player.style.left = Math.round(screenX) + 'px';
    player.style.top = Math.round(playerY) + 'px';
    
    // í”½ì…€ ì•„íŠ¸ ìºë¦­í„° í´ë˜ìŠ¤ ì ìš©
if (!player.classList.contains('pixel-knight')) {
    player.classList.add('pixel-knight');
}
    
    // ì›€ì§ì„ ì• ë‹ˆë©”ì´ì…˜
    if (Math.abs(velocityX) > 0.5 && isOnGround) {
        player.classList.add('player-walking');
    } else {
        player.classList.remove('player-walking');
    }
    
    // ì í”„ ì• ë‹ˆë©”ì´ì…˜
    if (!isOnGround) {
        player.classList.add('player-jumping');
    } else {
        player.classList.remove('player-jumping');
    }
    
    coordinates.textContent = `X: ${Math.round(playerX)}, Y: ${Math.round(playerY)} | Camera: ${Math.round(cameraX)}`;
}

// ì¹´ë©”ë¼ ì—…ë°ì´íŠ¸ í•¨ìˆ˜ (ë¶€ë“œëŸ¬ìš´ ì „í™˜)
function updateCamera() {
    const followPosition = screenWidth * 1/3; // 600px
    const leftBoundary = followPosition; // 600px
const rightBoundary = mapWidth - (screenWidth - followPosition); // 2400px
    
    let targetCameraX;
    
    if (playerX < leftBoundary) {
        // ì¢Œì¸¡ êµ¬ê°„: ì¹´ë©”ë¼ ê³ ì •
        targetCameraX = 0;
    } else if (playerX > rightBoundary) {
        // ìš°ì¸¡ êµ¬ê°„: ì¹´ë©”ë¼ ê³ ì •
        targetCameraX = mapWidth - screenWidth;
    } else {
        // ì¤‘ê°„ êµ¬ê°„: ìºë¦­í„° ë”°ë¼ê°€ê¸°
        targetCameraX = playerX - followPosition;
    }
    
    // ë¶€ë“œëŸ¬ìš´ ì¹´ë©”ë¼ ì´ë™ (ì„ íƒì‚¬í•­)
    // cameraX += (targetCameraX - cameraX) * 0.1;
    
    // ì¦‰ì‹œ ì´ë™
    cameraX = targetCameraX;
}
    
    // í‚¤ë³´ë“œ ì´ë²¤íŠ¸ ì²˜ë¦¬
    document.addEventListener('keydown', function(event) {
        console.log('Key pressed:', event.key, event.code); // ë””ë²„ê¹…ìš©
        
        switch(event.key.toLowerCase()) {
            case 'a':
                keys.left = true;
                event.preventDefault();
                break;
            case 'd':
                keys.right = true;
                event.preventDefault();
                break;

case 'z':
    if (showPortalMessage || showLeftPortalMessage) {
        moveToNextMap();
    }
    event.preventDefault();
    break;
            case ' ': //ìŠ¤í˜ì´ìŠ¤ ë°”
                keys.jump = true;
                event.preventDefault();
                break;
            case 's':
                keys.shoot = true;
                event.preventDefault();
                break;
            case 'arrowleft':
                keys.arrowLeft = true;
                event.preventDefault();
                break;
            case 'arrowright':
                keys.arrowRight = true;
                event.preventDefault();
                break;
            case 'arrowup':
                keys.arrowUp = true;
                event.preventDefault();
                break;
            case 'arrowdown':
                keys.arrowDown = true;
                event.preventDefault();
                break;
                case 'g':
    toggleInventory();
    event.preventDefault();
    break;
        }
    });
    
    document.addEventListener('keyup', function(event) {
        switch(event.key.toLowerCase()) {
            case 'a':
                keys.left = false;
                event.preventDefault();
                break;
            case 'd':
                keys.right = false;
                event.preventDefault();
                break;
            case ' ': // ìŠ¤í˜ì´ìŠ¤ë°”
                keys.jump = false;
                event.preventDefault();
                break;
            case 's':
                keys.shoot = false;
                event.preventDefault();
                break;
            case 'arrowleft':
                keys.arrowLeft = false;
                event.preventDefault();
                break;
            case 'arrowright':
                keys.arrowRight = false;
                event.preventDefault();
                break;
            case 'arrowup':
                keys.arrowUp = false;
                event.preventDefault();
                break;
            case 'arrowdown':
                keys.arrowDown = false;
                event.preventDefault();
                break;
        }
    });
    
    // êµ¬ê¸€ ì‹œíŠ¸ ì—°ë™ í•¨ìˆ˜ë“¤
    function loadPosition() {
        google.script.run
            .withSuccessHandler(function(data) {
                playerX = data.playerX;
                playerY = data.playerY;
                moveSpeed = data.moveSpeed;
                jumpPower = data.jumpPower;
                gravity = data.gravity;
                
                // ì†ë„ ì´ˆê¸°í™”
                velocityX = 0;
                velocityY = 0;
                
                updatePlayerPosition();
                alert('ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤!');
            })
            .withFailureHandler(function(error) {
                alert('ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ' + error);
            })
            .getGameData();
    }
    
    function savePosition() {
        google.script.run
            .withSuccessHandler(function(result) {
                alert('ìœ„ì¹˜ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!');
            })
            .withFailureHandler(function(error) {
                alert('ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ' + error);
            })
            .saveGameData(Math.round(playerX), Math.round(playerY));
    }
    
    function resetPosition() {
        google.script.run
            .withSuccessHandler(function(result) {
                playerX = 100;
                playerY = screenHeight - groundHeight - playerSize; // ë•… í‘œë©´ ë°”ë¡œ ìœ„
                velocityX = 0;
                velocityY = 0;
                diceShot = 0;
                totalDamage = 0;
                
                // ëª¨ë“  ì£¼ì‚¬ìœ„ ì œê±°
                diceArray.forEach(dice => dice.element.remove());
                diceArray = [];
                
                updatePlayerPosition();
                alert('ê²Œì„ì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤!');
            })
            .withFailureHandler(function(error) {
                alert('ì´ˆê¸°í™”ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ' + error);
            })
            .resetGame();
    }

    // í¬í„¸ ìƒì„± í•¨ìˆ˜ ìˆ˜ì • (ë°©í–¥ê³¼ ëª©ì ì§€ë¥¼ ë°›ë„ë¡)
function createMapPortal(direction = 'right', targetMap = null) {
    if (!targetMap) return;
    
    let portal, particles;
    
    if (direction === 'right') {
        portal = mapPortal = {
            element: document.createElement('div'),
            x: mapWidth - 150,
            y: screenHeight - groundHeight - 120,
            width: 80,
            height: 120,
            active: true,
            glowIntensity: 0,
            direction: 'right',
            targetMap: targetMap
        };
        particles = portalParticles;
    } else {
        portal = leftPortal = {
            element: document.createElement('div'),
            x: 70, // ë§µ ì¢Œì¸¡
            y: screenHeight - groundHeight - 120,
            width: 80,
            height: 120,
            active: true,
            glowIntensity: 0,
            direction: 'left',
            targetMap: targetMap
        };
        particles = leftPortalParticles;
    }
    
    portal.element.className = `map-portal ${direction}-portal`;
    portal.element.style.left = portal.x + 'px';
    portal.element.style.top = portal.y + 'px';
    
    // í¬í„¸ ë‚´ë¶€ êµ¬ì¡°
    portal.element.innerHTML = `
        <div class="portal-outer-ring"></div>
        <div class="portal-inner-ring"></div>
        <div class="portal-core"></div>
        <div class="portal-particles"></div>
    `;
    
    gameContainer.appendChild(portal.element);
    
    // í¬í„¸ë³„ íŒŒí‹°í´ ìƒì„±
    createPortalParticlesForPortal(portal, particles);
}

// íŠ¹ì • í¬í„¸ìš© íŒŒí‹°í´ ìƒì„±
function createPortalParticlesForPortal(portal, particleArray) {
    for (let i = 0; i < 15; i++) {
        const particle = {
            element: document.createElement('div'),
            x: portal.x + portal.width/2,
            y: portal.y + portal.height/2,
            angle: (Math.PI * 2 * i) / 15,
            radius: Math.random() * 30 + 20,
            speed: Math.random() * 0.02 + 0.01,
            opacity: Math.random() * 0.8 + 0.2,
            portalRef: portal
        };
        
        particle.element.className = 'portal-particle';
        particle.element.style.opacity = particle.opacity;
        gameContainer.appendChild(particle.element);
        particleArray.push(particle);
    }
}

// í¬í„¸ ë©”ì‹œì§€ ìƒì„±
function createPortalMessage() {
    if (document.getElementById('portalMessage')) return;
    
    const message = document.createElement('div');
    message.id = 'portalMessage';
    message.className = 'portal-message';
    message.innerHTML = `
        <div class="message-content">
            <div class="message-icon">ğŸŒ€</div>
            <div class="message-text">Zí‚¤ë¥¼ ëˆŒëŸ¬ ë‹¤ìŒ ë§µìœ¼ë¡œ ì´ë™</div>
        </div>
    `;
    
    gameContainer.appendChild(message);
}

// í¬í„¸ ë©”ì‹œì§€ ì œê±°
function removePortalMessage() {
    const message = document.getElementById('portalMessage');
    if (message) {
        message.remove();
    }
}

// í¬í„¸ ì—…ë°ì´íŠ¸ í•¨ìˆ˜ ìˆ˜ì •
function updatePortal() {
    updateSinglePortal(mapPortal, 'showPortalMessage');
    updateSinglePortal(leftPortal, 'showLeftPortalMessage');
}

// ë‹¨ì¼ í¬í„¸ ì—…ë°ì´íŠ¸
function updateSinglePortal(portal, messageFlag) {
    if (!portal) return;
    
    // ì¹´ë©”ë¼ ì˜¤í”„ì…‹ ì ìš©
    const screenX = portal.x - cameraX;
    portal.element.style.left = screenX + 'px';
    
    // í¬í„¸ê³¼ í”Œë ˆì´ì–´ ê±°ë¦¬ ê³„ì‚°
    const portalCenterX = portal.x + portal.width/2;
    const portalCenterY = portal.y + portal.height/2;
    const playerCenterX = playerX + playerSize/2;
    const playerCenterY = playerY + playerSize/2;
    
    const distance = Math.sqrt(
        Math.pow(portalCenterX - playerCenterX, 2) + 
        Math.pow(portalCenterY - playerCenterY, 2)
    );
    
    // í”Œë ˆì´ì–´ê°€ í¬í„¸ ê·¼ì²˜ì— ìˆëŠ”ì§€ í™•ì¸ (100px ì´ë‚´)
    if (distance < 100) {
        if (portal.direction === 'right' && !showPortalMessage) {
            showPortalMessage = true;
            createPortalMessage(portal.direction, portal.targetMap);
        } else if (portal.direction === 'left' && !showLeftPortalMessage) {
            showLeftPortalMessage = true;
            createPortalMessage(portal.direction, portal.targetMap);
        }
        
        portal.glowIntensity = Math.min(1, portal.glowIntensity + 0.02);
    } else {
        if (portal.direction === 'right' && showPortalMessage) {
            showPortalMessage = false;
            removePortalMessage();
        } else if (portal.direction === 'left' && showLeftPortalMessage) {
            showLeftPortalMessage = false;
            removePortalMessage();
        }
        
        portal.glowIntensity = Math.max(0.3, portal.glowIntensity - 0.02);
    }
    
    // í¬í„¸ ê¸€ë¡œìš° íš¨ê³¼ ì ìš©
    portal.element.style.filter = `brightness(${1 + portal.glowIntensity})`;
}

// í¬í„¸ íŒŒí‹°í´ ì—…ë°ì´íŠ¸
function updatePortalParticles() {
    portalParticles.forEach(particle => {
        // ì›í˜• ê¶¤ë„ë¡œ íšŒì „
        particle.angle += particle.speed;
        
        const centerX = mapPortal.x + mapPortal.width/2;
        const centerY = mapPortal.y + mapPortal.height/2;
        
        particle.x = centerX + Math.cos(particle.angle) * particle.radius;
        particle.y = centerY + Math.sin(particle.angle) * particle.radius;
        
        // ì¹´ë©”ë¼ ì˜¤í”„ì…‹ ì ìš©
        const screenX = particle.x - cameraX;
        particle.element.style.left = screenX + 'px';
        particle.element.style.top = particle.y + 'px';
        
        // íˆ¬ëª…ë„ ì• ë‹ˆë©”ì´ì…˜
        particle.opacity = 0.2 + Math.sin(particle.angle * 3) * 0.3;
        particle.element.style.opacity = Math.max(0.1, particle.opacity);
    });
}    
    // startGame í•¨ìˆ˜ ìˆ˜ì •
function startGame() {
    // íŠœí† ë¦¬ì–¼ ë§µìœ¼ë¡œ ì‹œì‘
    initializeMap('tutorial');
    gameLoop();
}
    
    // ë°ì´í„° ë¡œë”© ì™„ë£Œ ì²´í¬ ë³€ìˆ˜
let monsterDataLoaded = false;
let gameDataLoaded = false;

function checkAndStartGame() {
    if (monsterDataLoaded && gameDataLoaded) {
        startGame();
    }
}

window.onload = function() {
    // ëª¬ìŠ¤í„° ë°ì´í„° ë¡œë“œ
    google.script.run
        .withSuccessHandler(function(data) {
            monsterTypes = data;
            monsterTypes.dummy.className = 'training-dummy';
            monsterTypes.dummy.behavior = 'static';
            monsterTypes.slime.className = 'slime-monster';
            monsterTypes.slime.behavior = 'bounce';
            console.log('ëª¬ìŠ¤í„° ë°ì´í„° ë¡œë“œ ì™„ë£Œ:', monsterTypes);
            monsterDataLoaded = true;
            checkAndStartGame();
        })
        .withFailureHandler(function(error) {
            console.log('ëª¬ìŠ¤í„° ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨, ê¸°ë³¸ê°’ ì‚¬ìš©');
            monsterTypes = {
                dummy: {
                    width: 40, height: 60, maxHp: 1000, speed: 0, damage: 0,
                    className: 'training-dummy', behavior: 'static'
                },
                slime: {
                    width: 35, height: 30, maxHp: 100, speed: 1, damage: 10,
                    className: 'slime-monster', behavior: 'bounce'
                }
            };
            monsterDataLoaded = true;
            checkAndStartGame();
        })
        .getMonsterData();
    
    // ê²Œì„ ì„¤ì • ë¡œë“œ
    google.script.run
        .withSuccessHandler(function(data) {
            if (data) {
                moveSpeed = data.moveSpeed || moveSpeed;
                jumpPower = data.jumpPower || jumpPower;
                gravity = data.gravity || gravity;
                bulletSpeed = data.bulletSpeed || bulletSpeed;
                fireRate = data.fireRate || fireRate;
            }
            gameDataLoaded = true;
            checkAndStartGame();
        })
        .withFailureHandler(function(error) {
            console.log('ì„¤ì •ì„ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆì§€ë§Œ ê¸°ë³¸ê°’ìœ¼ë¡œ ì‹œì‘í•©ë‹ˆë‹¤.');
            gameDataLoaded = true;
            checkAndStartGame();
        })
        .getGameSettings();
};
</script>
