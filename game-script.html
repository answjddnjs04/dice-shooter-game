<script>
    // ê²Œì„ ìš”ì†Œë“¤
    let player = document.getElementById('player');
    let gameContainer = document.getElementById('gameContainer');
    let coordinates = document.getElementById('coordinates');
    let gameStats = document.getElementById('gameStats');
    
    // ê²Œì„ ì„¤ì •
// í™”ë©´ í¬ê¸° (ë³´ì´ëŠ” í™”ë©´)
const screenWidth = 1800;
const screenHeight = 900;

// ì‹¤ì œ ë§µ í¬ê¸° (ê°€ìƒì˜ ë§µ, 2ë°°)
const mapWidth = 3600;
const mapHeight = 900;

// ì¹´ë©”ë¼ ì˜¤í”„ì…‹
let cameraX = 0;
    const playerSize = 40;
    const groundHeight = 90;
    
    // í”Œë ˆì´ì–´ ìƒíƒœ
    let playerX = 100;
    let playerY = screenHeight - groundHeight - playerSize;
    let velocityX = 0;
    let velocityY = 0;
    
    // ê²Œì„ ì„¤ì • (êµ¬ê¸€ ì‹œíŠ¸ì—ì„œ ê°€ì ¸ì˜¬ ê°’ë“¤)
    let moveSpeed = 7;
    let jumpPower = 15;
    let gravity = 0.6;
    let friction = 0.8;
    let airResistance = 0.95;
    let bulletSpeed = 10;
    let fireRate = 300; // ë°€ë¦¬ì´ˆ
    
    // ì£¼ì‚¬ìœ„ ê´€ë ¨ ë³€ìˆ˜
    let diceArray = [];
    let diceShot = 0;
    let totalDamage = 0;
    let lastFireTime = 0;

    //êµ¬ë¦„ ê´€ë ¨ ë³€ìˆ˜
    let clouds = [];

    //íŠœí† ë¦¬ì–¼ ë³€ìˆ˜
    let tutorialSigns = [];
// í¬í„¸ ê´€ë ¨ ë³€ìˆ˜ë“¤
let mapPortal = null;
let leftPortal = null;
let portalParticles = [];
let leftPortalParticles = [];
let showPortalMessage = false;
let showLeftPortalMessage = false;

    // ì  ê´€ë ¨ ë³€ìˆ˜ (ìƒˆë¡œ ì¶”ê°€)
    let enemies = [];
    let damageIndicators = [];
    
    // ì…ë ¥ ìƒíƒœ
    let keys = {
    left: false,
    right: false,
    jump: false,
    shoot: false,
    arrowLeft: false,
    arrowRight: false,
    arrowUp: false,
    arrowDown: false
};
    
    let isOnGround = false;
    //ê²Œì„ ë£¨í”„
    function gameLoop() {
    handleInput();
    updatePhysics();
    updateDice();
    updateEnemies();
    updateDamageIndicators();
    checkDiceEnemyCollisions();
    updatePlayerPosition();
    updateTutorialSigns();
    updateClouds();
    updatePortal();           // ì¶”ê°€
    updatePortalParticles();  // ì¶”ê°€
    updateUI();
    requestAnimationFrame(gameLoop);
}
    //ì…ë ¥ ì²˜ë¦¬
    function handleInput() {
    // ì¢Œìš° ì´ë™ (ë•…ì—ì„œ ë” ë¹ ë¥´ê²Œ)
    if (keys.left) {
        if (isOnGround) {
            velocityX -= moveSpeed * 1.0;
        } else {
            velocityX -= moveSpeed * 0.1;
        }
    }
    if (keys.right) {
        if (isOnGround) {
            velocityX += moveSpeed * 0.15;
        } else {
            velocityX += moveSpeed * 0.1;
        }
    }
    
    // ì í”„ (ë•…ì— ìˆì„ ë•Œë§Œ)
    if (keys.jump && isOnGround) {
        velocityY = -jumpPower;
        isOnGround = false;
    }
    
    // ì£¼ì‚¬ìœ„ ë°œì‚¬ (Sí‚¤)
    if (keys.shoot) {
        fireDice(); // ê¸°ë³¸ ìš°ì¸¡ ë°œì‚¬
    }
    
    // í™”ì‚´í‘œí‚¤ë¡œ ë°©í–¥ ë°œì‚¬
    if (keys.arrowLeft) {
        fireDice(-1, 0); // ì™¼ìª½
    }
    if (keys.arrowRight) {
        fireDice(1, 0); // ì˜¤ë¥¸ìª½
    }
    if (keys.arrowUp) {
        fireDice(0, -1); // ìœ„ìª½
    }
    if (keys.arrowDown) {
        fireDice(0, 1); // ì•„ë˜ìª½
    }
}

    // ì£¼ì‚¬ìœ„ ëˆˆ ìƒì„± í•¨ìˆ˜ - ê°œì„ ëœ ë²„ì „
    function createDiceFace(value) {
        let dotsHTML = '';
        
        // ì£¼ì‚¬ìœ„ ëˆˆì— ë”°ë¼ ì  ìƒì„±
        for (let i = 0; i < value; i++) {
            dotsHTML += '<div class="dice-dot"></div>';
        }
        
        return dotsHTML;
    }

    // ì£¼ì‚¬ìœ„ ë°œì‚¬ í•¨ìˆ˜
    function fireDice(directionX = 1, directionY = 0) {
    const currentTime = Date.now();
    if (currentTime - lastFireTime < fireRate) return;
    
    lastFireTime = currentTime;
    diceShot++;




    // ì£¼ì‚¬ìœ„ ìƒì„±
    const dice = {
        element: document.createElement('div'),
        x: playerX + playerSize / 2,
        y: playerY + playerSize / 2,
        velocityX: bulletSpeed * directionX,
        velocityY: bulletSpeed * directionY,
        value: Math.floor(Math.random() * 6) + 1,
        life: 300,
        rollCounter: 0
    };
        
        // ì£¼ì‚¬ìœ„ ìš”ì†Œ ì„¤ì •
        dice.element.className = `dice dice-face-${dice.value}`;
        dice.element.innerHTML = createDiceFace(dice.value);
        dice.element.style.left = dice.x + 'px';
        dice.element.style.top = dice.y + 'px';
        
        gameContainer.appendChild(dice.element);
        diceArray.push(dice);
        
        totalDamage += dice.value;
    }
    // í—ˆìˆ˜ì•„ë¹„ ìƒì„± í•¨ìˆ˜
function createTrainingDummy() {
    const dummy = {
        element: document.createElement('div'),
        x: mapWidth - 600, // ë‚˜ë¬´ ê°„íŒ ë°‘ìœ¼ë¡œ ì´ë™ (ë” ì™¼ìª½ìœ¼ë¡œ)
        y: screenHeight - groundHeight - 60,
            width: 40,
            height: 60,
            maxHp: 1000,
            currentHp: 1000,
            type: 'dummy'
        };
        
        dummy.element.className = 'training-dummy';
        dummy.element.style.left = dummy.x + 'px';
        dummy.element.style.top = dummy.y + 'px';
        
        const hpBar = document.createElement('div');
        hpBar.className = 'enemy-hp-bar';
        hpBar.innerHTML = `
            <div class="hp-bar-background">
                <div class="hp-bar-fill"></div>
                <div class="hp-bar-text">${dummy.currentHp}/${dummy.maxHp}</div>
            </div>
        `;
        dummy.element.appendChild(hpBar);
        
        gameContainer.appendChild(dummy.element);
        enemies.push(dummy);
    }

    // ì  ì—…ë°ì´íŠ¸ í•¨ìˆ˜
function updateEnemies() {
    enemies.forEach(enemy => {
        // ì¹´ë©”ë¼ ì˜¤í”„ì…‹ ì ìš©í•˜ì—¬ í™”ë©´ìƒ ìœ„ì¹˜ ê³„ì‚°
        const screenX = enemy.x - cameraX;
        enemy.element.style.left = screenX + 'px';
        enemy.element.style.top = enemy.y + 'px'; // Y ìœ„ì¹˜ë„ ëª…ì‹œì ìœ¼ë¡œ ì„¤ì •
        
        if (enemy.type === 'dummy') {
            const hpFill = enemy.element.querySelector('.hp-bar-fill');
            const hpText = enemy.element.querySelector('.hp-bar-text');
            
            const hpPercent = (enemy.currentHp / enemy.maxHp) * 100;
            hpFill.style.width = hpPercent + '%';
            hpText.textContent = `${enemy.currentHp}/${enemy.maxHp}`;
        }
    });
}

    // ë°ë¯¸ì§€ í‘œì‹œê¸° ìƒì„± (ë°˜ì› ë²”ìœ„)
function createDamageIndicator(enemyX, enemyY, enemyWidth, diceValue) {
    // ì ì˜ ë¨¸ë¦¬ ì¤‘ì•™ ìœ„ì¹˜
    const headCenterX = enemyX + enemyWidth / 2;
    const headY = enemyY - 10; // ë¨¸ë¦¬ ìœ„ìª½
    
    // ë°˜ì› ë²”ìœ„ì—ì„œ ëœë¤ ìœ„ì¹˜ ê³„ì‚°
    const radius = 40; // ë°˜ì› ë°˜ì§€ë¦„
    const angle = Math.random() * Math.PI; // 0 ~ Ï€ (ë°˜ì›)
    
    const offsetX = Math.cos(angle) * (Math.random() * radius);
    const offsetY = -Math.sin(angle) * (Math.random() * radius); // ìœ„ìª½ìœ¼ë¡œë§Œ
    
    const indicator = {
        element: document.createElement('div'),
        x: headCenterX + offsetX,
        y: headY + offsetY,
        life: 150, // ì¡°ê¸ˆ ë” ì§§ê²Œ
        diceValue: diceValue
    };
    
    indicator.element.className = 'damage-indicator';
    indicator.element.textContent = `-${diceValue}`;
    
    // ì¹´ë©”ë¼ ì˜¤í”„ì…‹ ì ìš©ëœ ìœ„ì¹˜
    const screenX = indicator.x - cameraX;
    indicator.element.style.left = screenX + 'px';
    indicator.element.style.top = indicator.y + 'px';
    
    gameContainer.appendChild(indicator.element);
    damageIndicators.push(indicator);
}

    // ë°ë¯¸ì§€ í‘œì‹œê¸° ì—…ë°ì´íŠ¸
function updateDamageIndicators() {
    for (let i = damageIndicators.length - 1; i >= 0; i--) {
        const indicator = damageIndicators[i];
        
        // ì¹´ë©”ë¼ ì˜¤í”„ì…‹ ì ìš©
        const screenX = indicator.x - cameraX;
        indicator.element.style.left = screenX + 'px';
        
        indicator.life--;
        
        if (indicator.life < 60) {
            const opacity = indicator.life / 60;
            indicator.element.style.opacity = opacity;
        }
        
        if (indicator.life <= 0) {
            indicator.element.remove();
            damageIndicators.splice(i, 1);
        }
    }
}

    // ì£¼ì‚¬ìœ„ì™€ ì  ì¶©ëŒ ê²€ì‚¬
    function checkDiceEnemyCollisions() {
        for (let i = diceArray.length - 1; i >= 0; i--) {
            const dice = diceArray[i];
            
            for (let j = 0; j < enemies.length; j++) {
                const enemy = enemies[j];
                
                if (dice.x < enemy.x + enemy.width &&
                    dice.x + 25 > enemy.x &&
                    dice.y < enemy.y + enemy.height &&
                    dice.y + 25 > enemy.y) {
                    
                    enemy.currentHp -= dice.value;
                    if (enemy.currentHp < 0) enemy.currentHp = 0;
                    
                    createDamageIndicator(enemy.x, enemy.y, enemy.width, dice.value);
                    
                    dice.element.remove();
                    diceArray.splice(i, 1);
                    break;
                }
            }
        }
    }
    // ì£¼ì‚¬ìœ„ ì—…ë°ì´íŠ¸
    function updateDice() {
        for (let i = diceArray.length - 1; i >= 0; i--) {
            const dice = diceArray[i];
            
            // ì£¼ì‚¬ìœ„ ì´ë™
            dice.x += dice.velocityX;
            dice.y += dice.velocityY;
            
            // ì£¼ì‚¬ìœ„ ëˆˆ ëœë¤ ë³€ê²½ (ë” ì•ˆì •ì ìœ¼ë¡œ)
            dice.rollCounter++;
            if (dice.rollCounter % 40 === 0) { // 20í”„ë ˆì„ë§ˆë‹¤ ë³€ê²½ (ë” ì²œì²œíˆ)
                const oldValue = dice.value;
                dice.value = Math.floor(Math.random() * 6) + 1;
                
                // ê°’ì´ ë°”ë€Œì—ˆì„ ë•Œë§Œ ì—…ë°ì´íŠ¸
                if (oldValue !== dice.value) {
                    dice.element.className = `dice dice-face-${dice.value}`;
                    dice.element.innerHTML = createDiceFace(dice.value);
                    
                    // ì´ ë°ë¯¸ì§€ ì—…ë°ì´íŠ¸ (ì´ì „ ê°’ ë¹¼ê³  ìƒˆ ê°’ ë”í•˜ê¸°)
                    totalDamage = totalDamage - oldValue + dice.value;
                }
            }
            
            // ìœ„ì¹˜ ì—…ë°ì´íŠ¸ (ì¹´ë©”ë¼ ì˜¤í”„ì…‹ ì ìš©)
const screenX = dice.x - cameraX;
dice.element.style.left = screenX + 'px';
dice.element.style.top = dice.y + 'px';
            
            // ìˆ˜ëª… ê°ì†Œ
            dice.life--;
            
            // ë§µ ë°–ìœ¼ë¡œ ë‚˜ê°€ê±°ë‚˜ ìˆ˜ëª…ì´ ë‹¤í•˜ë©´ ì œê±°
if (dice.x > mapWidth || dice.y > screenHeight || dice.life <= 0 || dice.x < 0) {
                dice.element.remove();
                diceArray.splice(i, 1);
            }
        }
    }
    
    // UI ì—…ë°ì´íŠ¸
    function updateUI() {
        gameStats.textContent = `ì£¼ì‚¬ìœ„: ${diceShot}ë°œ | ì´ ë°ë¯¸ì§€: ${totalDamage}`;
    }
   
    // êµ¬ë¦„ ìƒì„± í•¨ìˆ˜
function createClouds() {
    const cloudTypes = ['cloud-small', 'cloud-medium', 'cloud-large'];
    
    for (let i = 0; i < 8; i++) {
        const cloud = {
            element: document.createElement('div'),
            x: Math.random() * mapWidth,
            y: Math.random() * 200 + 50, // í•˜ëŠ˜ ìœ„ìª½ì—ë§Œ
            type: cloudTypes[Math.floor(Math.random() * cloudTypes.length)]
        };
        
        cloud.element.className = `cloud ${cloud.type}`;
        cloud.element.style.left = cloud.x + 'px';
        cloud.element.style.top = cloud.y + 'px';
        
        gameContainer.appendChild(cloud.element);
        clouds.push(cloud);
    }
}

// êµ¬ë¦„ ìœ„ì¹˜ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
function updateClouds() {
    clouds.forEach(cloud => {
        // ì¹´ë©”ë¼ ì˜¤í”„ì…‹ ì ìš©
        const screenX = cloud.x - cameraX;
        cloud.element.style.left = screenX + 'px';
    });
}
// game-script.htmlì— ì¶”ê°€/ìˆ˜ì •í•  ì½”ë“œ

// ë§µ ê´€ë ¨ ë³€ìˆ˜ ì¶”ê°€ (ê¸°ì¡´ ë³€ìˆ˜ë“¤ê³¼ í•¨ê»˜)
let maps = {
    tutorial: {
        name: 'tutorial',
        hasEnemies: true,
        hasTutorialSigns: true,
        portals: {
            right: 'stage1', // ìš°ì¸¡ í¬í„¸ë¡œ stage1ìœ¼ë¡œ ì´ë™
            left: null       // ì¢Œì¸¡ í¬í„¸ ì—†ìŒ
        }
    },
    stage1: {
        name: 'stage1',
        hasEnemies: false,
        hasTutorialSigns: false,
        portals: {
            right: null,      // ìš°ì¸¡ í¬í„¸ ì—†ìŒ (ë‚˜ì¤‘ì— ì¶”ê°€ ê°€ëŠ¥)
            left: 'tutorial'  // ì¢Œì¸¡ í¬í„¸ë¡œ tutorialë¡œ ëŒì•„ê°€ê¸°
        }
    }
};

// ë§µ ì´ˆê¸°í™” í•¨ìˆ˜
function initializeMap(mapName, fromPortal = false) {
    currentMap = mapName;
    const mapData = maps[mapName];
    
    // ê¸°ì¡´ ìš”ì†Œë“¤ ì œê±°
    clearMapElements();
    
    // í”Œë ˆì´ì–´ ìœ„ì¹˜ ì´ˆê¸°í™”
    if (mapName === 'tutorial') {
        if (fromPortal) {
            // ë§µ1ì—ì„œ ëŒì•„ì˜¬ ë•ŒëŠ” ìš°ì¸¡ í¬í„¸ ê·¼ì²˜ì— ë°°ì¹˜
            playerX = mapWidth - 300; // ìš°ì¸¡ í¬í„¸ ê·¼ì²˜
        } else {
            // ì²« ì‹œì‘ì´ê±°ë‚˜ ì´ˆê¸°í™”í•  ë•ŒëŠ” ì™¼ìª½ì— ë°°ì¹˜
            playerX = 100;
        }
    } else if (mapName === 'stage1') {
        playerX = 100; // stage1 ì‹œì‘ ìœ„ì¹˜
    }
    playerY = screenHeight - groundHeight - playerSize;
    velocityX = 0;
    velocityY = 0;
    
    // ì¹´ë©”ë¼ ìœ„ì¹˜ ì´ˆê¸°í™”
    cameraX = 0;
    
    // ë§µë³„ ìš”ì†Œ ìƒì„±
    createMapElements(mapData);
    
    updatePlayerPosition();
}

// ë§µ ìš”ì†Œë“¤ ì œê±° í•¨ìˆ˜
function clearMapElements() {
    // ì ë“¤ ì œê±°
    enemies.forEach(enemy => {
        if (enemy.element && enemy.element.parentNode) {
            enemy.element.remove();
        }
    });
    enemies = [];
    
    // íŠœí† ë¦¬ì–¼ ì‚¬ì¸ë“¤ ì œê±°
    tutorialSigns.forEach(sign => {
        if (sign.element && sign.element.parentNode) {
            sign.element.remove();
        }
    });
    tutorialSigns = [];
    
    // í¬í„¸ë“¤ ì œê±°
    if (mapPortal && mapPortal.element && mapPortal.element.parentNode) {
        mapPortal.element.remove();
    }
    if (leftPortal && leftPortal.element && leftPortal.element.parentNode) {
        leftPortal.element.remove();
    }
    mapPortal = null;
    leftPortal = null;
    
    // í¬í„¸ íŒŒí‹°í´ë“¤ ì œê±°
    portalParticles.forEach(particle => {
        if (particle.element && particle.element.parentNode) {
            particle.element.remove();
        }
    });
    portalParticles = [];
    
    leftPortalParticles.forEach(particle => {
        if (particle.element && particle.element.parentNode) {
            particle.element.remove();
        }
    });
    leftPortalParticles = [];
    
    // ì£¼ì‚¬ìœ„ë“¤ ì œê±°
    diceArray.forEach(dice => {
        if (dice.element && dice.element.parentNode) {
            dice.element.remove();
        }
    });
    diceArray = [];
    
    // ë°ë¯¸ì§€ ì¸ë””ì¼€ì´í„°ë“¤ ì œê±°
    damageIndicators.forEach(indicator => {
        if (indicator.element && indicator.element.parentNode) {
            indicator.element.remove();
        }
    });
    damageIndicators = [];
    
    // í¬í„¸ ë©”ì‹œì§€ ì œê±°
    removePortalMessage();
    
    // í†µê³„ ì´ˆê¸°í™”
    diceShot = 0;
    totalDamage = 0;
}

// ë§µ ìš”ì†Œë“¤ ìƒì„± í•¨ìˆ˜
function createMapElements(mapData) {
    // êµ¬ë¦„ì€ ëª¨ë“  ë§µì— ìƒì„±
    createClouds();
    
    // ë§µë³„ ìš”ì†Œ ìƒì„±
    if (mapData.hasEnemies) {
        createTrainingDummy();
    }
    
    if (mapData.hasTutorialSigns) {
        createTutorialSigns();
    }
    
    // í¬í„¸ ìƒì„±
    if (mapData.portals.right) {
        createMapPortal('right', mapData.portals.right);
    }
    
    if (mapData.portals.left) {
        createMapPortal('left', mapData.portals.left);
    }
}

// í¬í„¸ ìƒì„± í•¨ìˆ˜ ìˆ˜ì • (ë°©í–¥ê³¼ ëª©ì ì§€ë¥¼ ë°›ë„ë¡)
function createMapPortal(direction = 'right', targetMap = null) {
    if (!targetMap) return;
    
    let portal, particles;
    
    if (direction === 'right') {
        portal = mapPortal = {
            element: document.createElement('div'),
            x: mapWidth - 150,
            y: screenHeight - groundHeight - 120,
            width: 80,
            height: 120,
            active: true,
            glowIntensity: 0,
            direction: 'right',
            targetMap: targetMap
        };
        particles = portalParticles;
    } else {
        portal = leftPortal = {
            element: document.createElement('div'),
            x: 70, // ë§µ ì¢Œì¸¡
            y: screenHeight - groundHeight - 120,
            width: 80,
            height: 120,
            active: true,
            glowIntensity: 0,
            direction: 'left',
            targetMap: targetMap
        };
        particles = leftPortalParticles;
    }
    
    portal.element.className = `map-portal ${direction}-portal`;
    portal.element.style.left = portal.x + 'px';
    portal.element.style.top = portal.y + 'px';
    
    // í¬í„¸ ë‚´ë¶€ êµ¬ì¡°
    portal.element.innerHTML = `
        <div class="portal-outer-ring"></div>
        <div class="portal-inner-ring"></div>
        <div class="portal-core"></div>
        <div class="portal-particles"></div>
    `;
    
    gameContainer.appendChild(portal.element);
    
    // í¬í„¸ë³„ íŒŒí‹°í´ ìƒì„±
    createPortalParticlesForPortal(portal, particles);
}

// íŠ¹ì • í¬í„¸ìš© íŒŒí‹°í´ ìƒì„±
function createPortalParticlesForPortal(portal, particleArray) {
    for (let i = 0; i < 15; i++) {
        const particle = {
            element: document.createElement('div'),
            x: portal.x + portal.width/2,
            y: portal.y + portal.height/2,
            angle: (Math.PI * 2 * i) / 15,
            radius: Math.random() * 30 + 20,
            speed: Math.random() * 0.02 + 0.01,
            opacity: Math.random() * 0.8 + 0.2,
            portalRef: portal
        };
        
        particle.element.className = 'portal-particle';
        particle.element.style.opacity = particle.opacity;
        gameContainer.appendChild(particle.element);
        particleArray.push(particle);
    }
}

// í¬í„¸ ì—…ë°ì´íŠ¸ í•¨ìˆ˜ ìˆ˜ì •
function updatePortal() {
    updateSinglePortal(mapPortal, 'showPortalMessage');
    updateSinglePortal(leftPortal, 'showLeftPortalMessage');
}

// ë‹¨ì¼ í¬í„¸ ì—…ë°ì´íŠ¸
function updateSinglePortal(portal, messageFlag) {
    if (!portal) return;
    
    // ì¹´ë©”ë¼ ì˜¤í”„ì…‹ ì ìš©
    const screenX = portal.x - cameraX;
    portal.element.style.left = screenX + 'px';
    
    // í¬í„¸ê³¼ í”Œë ˆì´ì–´ ê±°ë¦¬ ê³„ì‚°
    const portalCenterX = portal.x + portal.width/2;
    const portalCenterY = portal.y + portal.height/2;
    const playerCenterX = playerX + playerSize/2;
    const playerCenterY = playerY + playerSize/2;
    
    const distance = Math.sqrt(
        Math.pow(portalCenterX - playerCenterX, 2) + 
        Math.pow(portalCenterY - playerCenterY, 2)
    );
    
    // í”Œë ˆì´ì–´ê°€ í¬í„¸ ê·¼ì²˜ì— ìˆëŠ”ì§€ í™•ì¸ (100px ì´ë‚´)
    if (distance < 100) {
        if (portal.direction === 'right' && !showPortalMessage) {
            showPortalMessage = true;
            createPortalMessage(portal.direction, portal.targetMap);
        } else if (portal.direction === 'left' && !showLeftPortalMessage) {
            showLeftPortalMessage = true;
            createPortalMessage(portal.direction, portal.targetMap);
        }
        
        portal.glowIntensity = Math.min(1, portal.glowIntensity + 0.02);
    } else {
        if (portal.direction === 'right' && showPortalMessage) {
            showPortalMessage = false;
            removePortalMessage();
        } else if (portal.direction === 'left' && showLeftPortalMessage) {
            showLeftPortalMessage = true;
            removePortalMessage();
        }
        
        portal.glowIntensity = Math.max(0.3, portal.glowIntensity - 0.02);
    }
    
    // í¬í„¸ ê¸€ë¡œìš° íš¨ê³¼ ì ìš©
    portal.element.style.filter = `brightness(${1 + portal.glowIntensity})`;
}

// í¬í„¸ ë©”ì‹œì§€ ìƒì„± ìˆ˜ì •
function createPortalMessage(direction = 'right', targetMap = '') {
    if (document.getElementById('portalMessage')) return;
    
    const message = document.createElement('div');
    message.id = 'portalMessage';
    message.className = 'portal-message';
    
    let mapDisplayName = '';
    if (targetMap === 'tutorial') {
        mapDisplayName = 'íŠœí† ë¦¬ì–¼ ë§µ';
    } else if (targetMap === 'stage1') {
        mapDisplayName = 'ìŠ¤í…Œì´ì§€ 1';
    }
    
    message.innerHTML = `
        <div class="message-content">
            <div class="message-icon">ğŸŒ€</div>
            <div class="message-text">Zí‚¤ë¥¼ ëˆŒëŸ¬ ${mapDisplayName}ìœ¼ë¡œ ì´ë™</div>
        </div>
    `;
    
    gameContainer.appendChild(message);
}

// í¬í„¸ íŒŒí‹°í´ ì—…ë°ì´íŠ¸ ìˆ˜ì •
function updatePortalParticles() {
    updateParticleArray(portalParticles);
    updateParticleArray(leftPortalParticles);
}

function updateParticleArray(particleArray) {
    particleArray.forEach(particle => {
        // ì›í˜• ê¶¤ë„ë¡œ íšŒì „
        particle.angle += particle.speed;
        
        const portal = particle.portalRef;
        const centerX = portal.x + portal.width/2;
        const centerY = portal.y + portal.height/2;
        
        particle.x = centerX + Math.cos(particle.angle) * particle.radius;
        particle.y = centerY + Math.sin(particle.angle) * particle.radius;
        
        // ì¹´ë©”ë¼ ì˜¤í”„ì…‹ ì ìš©
        const screenX = particle.x - cameraX;
        particle.element.style.left = screenX + 'px';
        particle.element.style.top = particle.y + 'px';
        
        // íˆ¬ëª…ë„ ì• ë‹ˆë©”ì´ì…˜
        particle.opacity = 0.2 + Math.sin(particle.angle * 3) * 0.3;
        particle.element.style.opacity = Math.max(0.1, particle.opacity);
    });
}

// ë‹¤ìŒ ë§µìœ¼ë¡œ ì´ë™ í•¨ìˆ˜ ìˆ˜ì • (ìƒì„¸í•œ ë¡œê·¸ í¬í•¨)
function moveToNextMap() {
    console.log('=== moveToNextMap í•¨ìˆ˜ ì‹œì‘ ===');
    console.log('showPortalMessage:', showPortalMessage);
    console.log('showLeftPortalMessage:', showLeftPortalMessage);
    console.log('mapPortal:', mapPortal);
    console.log('leftPortal:', leftPortal);
    
    let targetMap = null;
    
    // ì–´ëŠ í¬í„¸ì„ ì‚¬ìš©í•˜ëŠ”ì§€ í™•ì¸
    if (showPortalMessage && mapPortal) {
        targetMap = mapPortal.targetMap;
        console.log('ìš°ì¸¡ í¬í„¸ ì‚¬ìš©, targetMap:', targetMap);
    } else if (showLeftPortalMessage && leftPortal) {
        targetMap = leftPortal.targetMap;
        console.log('ì¢Œì¸¡ í¬í„¸ ì‚¬ìš©, targetMap:', targetMap);
    }
    
    console.log('ìµœì¢… targetMap:', targetMap);
    
    if (!targetMap) {
        console.log('targetMapì´ ì—†ì–´ì„œ í•¨ìˆ˜ ì¢…ë£Œ');
        return;
    }
    
    // í¬í„¸ ì§„ì… íš¨ê³¼
    const portalEffect = document.createElement('div');
    portalEffect.className = 'portal-transition-effect';
    document.body.appendChild(portalEffect);
    
    console.log(`${targetMap} ë§µìœ¼ë¡œ ì´ë™ ì‹œì‘!`);
    
    // targetMapì„ setTimeout ì•ˆì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ ì €ì¥
    const nextMap = targetMap;
    console.log('nextMap ë³€ìˆ˜ì— ì €ì¥:', nextMap);
    
    setTimeout(() => {
    console.log('setTimeout ì‹¤í–‰, nextMap:', nextMap);
    // ë§µ ì „í™˜ (í¬í„¸ì„ í†µí•´ ì´ë™í–ˆë‹¤ëŠ” ê²ƒì„ í‘œì‹œ)
    initializeMap(nextMap, true);
    portalEffect.remove();
        
        // ë©”ì‹œì§€ í”Œë˜ê·¸ ì´ˆê¸°í™”
        showPortalMessage = false;
        showLeftPortalMessage = false;
        console.log('ë§µ ì „í™˜ ì™„ë£Œ');
    }, 1000);
}

// startGame í•¨ìˆ˜ ìˆ˜ì •
function startGame() {
    // íŠœí† ë¦¬ì–¼ ë§µìœ¼ë¡œ ì‹œì‘
    initializeMap('tutorial');
    gameLoop();
}
// íŠœí† ë¦¬ì–¼ ì‚¬ì¸ ìƒì„± í•¨ìˆ˜
function createTutorialSigns() {
    const tutorials = [
        {
            x: 400,
            y: screenHeight - groundHeight - 180,
            text: "A/Dí‚¤ë¡œ\nì¢Œìš° ì´ë™",
            arrow: "â†â†’"
        },
        {
            x: 900,
            y: screenHeight - groundHeight - 180,
            text: "ìŠ¤í˜ì´ìŠ¤ë°”ë¡œ\nì í”„",
            arrow: "â†‘"
        },
        {
            x: 1400,
            y: screenHeight - groundHeight - 180,
            text: "í™”ì‚´í‘œí‚¤ë¡œ\nì£¼ì‚¬ìœ„ ë°œì‚¬",
            arrow: "ğŸ²"
        },
        {
            x: mapWidth - 695,
            y: screenHeight - groundHeight - 200,
            text: "í—ˆìˆ˜ì•„ë¹„ë¥¼\nê³µê²©í•´ë³´ì„¸ìš”!",
            arrow: "ğŸ¯"
        }
    ];
    
    tutorials.forEach((tutorial, index) => {
        // ì‚¬ì¸ ìƒì„±
        const sign = {
            element: document.createElement('div'),
            x: tutorial.x,
            y: tutorial.y,
            id: `tutorial-${index}`
        };
        
        sign.element.className = 'tutorial-sign';
        sign.element.innerHTML = tutorial.text.replace('\n', '<br>');
        sign.element.style.left = tutorial.x + 'px';
        sign.element.style.top = tutorial.y + 'px';
        
        gameContainer.appendChild(sign.element);
        tutorialSigns.push(sign);
        
        // í™”ì‚´í‘œ ìƒì„±
        const arrow = {
            element: document.createElement('div'),
            x: tutorial.x,
            y: tutorial.y - 40,
            signIndex: index
        };
        
        arrow.element.className = 'tutorial-arrow';
        arrow.element.textContent = tutorial.arrow;
        arrow.element.style.left = (tutorial.x + 100) + 'px';
        arrow.element.style.top = (tutorial.y - 40) + 'px';
        
        gameContainer.appendChild(arrow.element);
        tutorialSigns.push(arrow);
    });
}

// íŠœí† ë¦¬ì–¼ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
function updateTutorialSigns() {
    tutorialSigns.forEach(sign => {
        // ì¹´ë©”ë¼ ì˜¤í”„ì…‹ ì ìš©
        const screenX = sign.x - cameraX;
        sign.element.style.left = screenX + 'px';
    });
}
    // ë¬¼ë¦¬ ì—”ì§„
    function updatePhysics() {
        // ì¤‘ë ¥ ì ìš©
        velocityY += gravity;
        
        // ê³µê¸° ì €í•­
if (!isOnGround) {
    velocityX *= airResistance;
} else {
    // ë•…ì—ì„œì˜ ë§ˆì°°
    velocityX *= friction;
}
        
        // ìµœëŒ€ ì†ë„ ì œí•œ
        const maxVelocityX = moveSpeed;
        const maxVelocityY = 25;
        
        if (velocityX > maxVelocityX) velocityX = maxVelocityX;
        if (velocityX < -maxVelocityX) velocityX = -maxVelocityX;
        if (velocityY > maxVelocityY) velocityY = maxVelocityY;
        
        // ìœ„ì¹˜ ì—…ë°ì´íŠ¸
        playerX += velocityX;
        playerY += velocityY;
        
        // ê²½ê³„ ì¶©ëŒ ê²€ì‚¬
        checkCollisions();
    }
    
    // ì¶©ëŒ ê²€ì‚¬
    function checkCollisions() {
        // ì¢Œìš° ë²½ ì¶©ëŒ (ë§µ í¬ê¸° ê¸°ì¤€)
if (playerX < 0) {
    playerX = 0;
    velocityX = 0;
}
if (playerX > mapWidth - playerSize) {
    playerX = mapWidth - playerSize;
    velocityX = 0;
}
        
        // ë•… ì¶©ëŒ
        // ë•… ì¶©ëŒ (ìºë¦­í„° ë°œì´ ë•… í‘œë©´ì— ì •í™•íˆ ë‹¿ë„ë¡)
const groundSurfaceY = screenHeight - groundHeight; // ë•…ì˜ í‘œë©´ ìœ„ì¹˜
const groundY = groundSurfaceY - playerSize; // ìºë¦­í„°ê°€ ë•… ìœ„ì— ì„œëŠ” ìœ„ì¹˜
if (playerY >= groundY) {
    playerY = groundY;
    velocityY = 0;
    isOnGround = true;
} else {
    isOnGround = false;
}
        
        // ì²œì¥ ì¶©ëŒ
        if (playerY < 0) {
            playerY = 0;
            velocityY = 0;
        }
    }
    
    // í”Œë ˆì´ì–´ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
function updatePlayerPosition() {
    updateCamera();
    
    // ì¹´ë©”ë¼ ì˜¤í”„ì…‹ì„ ì ìš©í•œ í™”ë©´ìƒ ìœ„ì¹˜
    const screenX = playerX - cameraX;
    
    player.style.left = Math.round(screenX) + 'px';
    player.style.top = Math.round(playerY) + 'px';
    coordinates.textContent = `X: ${Math.round(playerX)}, Y: ${Math.round(playerY)} | Camera: ${Math.round(cameraX)}`;
}

// ì¹´ë©”ë¼ ì—…ë°ì´íŠ¸ í•¨ìˆ˜ (ë¶€ë“œëŸ¬ìš´ ì „í™˜)
function updateCamera() {
    const followPosition = screenWidth * 1/3; // 600px
    const leftBoundary = followPosition; // 600px
const rightBoundary = mapWidth - (screenWidth - followPosition); // 2400px
    
    let targetCameraX;
    
    if (playerX < leftBoundary) {
        // ì¢Œì¸¡ êµ¬ê°„: ì¹´ë©”ë¼ ê³ ì •
        targetCameraX = 0;
    } else if (playerX > rightBoundary) {
        // ìš°ì¸¡ êµ¬ê°„: ì¹´ë©”ë¼ ê³ ì •
        targetCameraX = mapWidth - screenWidth;
    } else {
        // ì¤‘ê°„ êµ¬ê°„: ìºë¦­í„° ë”°ë¼ê°€ê¸°
        targetCameraX = playerX - followPosition;
    }
    
    // ë¶€ë“œëŸ¬ìš´ ì¹´ë©”ë¼ ì´ë™ (ì„ íƒì‚¬í•­)
    // cameraX += (targetCameraX - cameraX) * 0.1;
    
    // ì¦‰ì‹œ ì´ë™
    cameraX = targetCameraX;
}
    
    // í‚¤ë³´ë“œ ì´ë²¤íŠ¸ ì²˜ë¦¬
    document.addEventListener('keydown', function(event) {
        console.log('Key pressed:', event.key, event.code); // ë””ë²„ê¹…ìš©
        
        switch(event.key.toLowerCase()) {
            case 'a':
                keys.left = true;
                event.preventDefault();
                break;
            case 'd':
                keys.right = true;
                event.preventDefault();
                break;

case 'z':
    if (showPortalMessage || showLeftPortalMessage) {
        moveToNextMap();
    }
    event.preventDefault();
    break;
            case ' ': //ìŠ¤í˜ì´ìŠ¤ ë°”
                keys.jump = true;
                event.preventDefault();
                break;
            case 's':
                keys.shoot = true;
                event.preventDefault();
                break;
            case 'arrowleft':
                keys.arrowLeft = true;
                event.preventDefault();
                break;
            case 'arrowright':
                keys.arrowRight = true;
                event.preventDefault();
                break;
            case 'arrowup':
                keys.arrowUp = true;
                event.preventDefault();
                break;
            case 'arrowdown':
                keys.arrowDown = true;
                event.preventDefault();
                break;
        }
    });
    
    document.addEventListener('keyup', function(event) {
        switch(event.key.toLowerCase()) {
            case 'a':
                keys.left = false;
                event.preventDefault();
                break;
            case 'd':
                keys.right = false;
                event.preventDefault();
                break;
            case ' ': // ìŠ¤í˜ì´ìŠ¤ë°”
                keys.jump = false;
                event.preventDefault();
                break;
            case 's':
                keys.shoot = false;
                event.preventDefault();
                break;
            case 'arrowleft':
                keys.arrowLeft = false;
                event.preventDefault();
                break;
            case 'arrowright':
                keys.arrowRight = false;
                event.preventDefault();
                break;
            case 'arrowup':
                keys.arrowUp = false;
                event.preventDefault();
                break;
            case 'arrowdown':
                keys.arrowDown = false;
                event.preventDefault();
                break;
        }
    });
    
    // êµ¬ê¸€ ì‹œíŠ¸ ì—°ë™ í•¨ìˆ˜ë“¤
    function loadPosition() {
        google.script.run
            .withSuccessHandler(function(data) {
                playerX = data.playerX;
                playerY = data.playerY;
                moveSpeed = data.moveSpeed;
                jumpPower = data.jumpPower;
                gravity = data.gravity;
                
                // ì†ë„ ì´ˆê¸°í™”
                velocityX = 0;
                velocityY = 0;
                
                updatePlayerPosition();
                alert('ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤!');
            })
            .withFailureHandler(function(error) {
                alert('ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ' + error);
            })
            .getGameData();
    }
    
    function savePosition() {
        google.script.run
            .withSuccessHandler(function(result) {
                alert('ìœ„ì¹˜ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!');
            })
            .withFailureHandler(function(error) {
                alert('ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ' + error);
            })
            .saveGameData(Math.round(playerX), Math.round(playerY));
    }
    
    function resetPosition() {
        google.script.run
            .withSuccessHandler(function(result) {
                playerX = 100;
                playerY = screenHeight - groundHeight - playerSize; // ë•… í‘œë©´ ë°”ë¡œ ìœ„
                velocityX = 0;
                velocityY = 0;
                diceShot = 0;
                totalDamage = 0;
                
                // ëª¨ë“  ì£¼ì‚¬ìœ„ ì œê±°
                diceArray.forEach(dice => dice.element.remove());
                diceArray = [];
                
                updatePlayerPosition();
                alert('ê²Œì„ì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤!');
            })
            .withFailureHandler(function(error) {
                alert('ì´ˆê¸°í™”ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ' + error);
            })
            .resetGame();
    }

    // í¬í„¸ ìƒì„± í•¨ìˆ˜ ìˆ˜ì • (ë°©í–¥ê³¼ ëª©ì ì§€ë¥¼ ë°›ë„ë¡)
function createMapPortal(direction = 'right', targetMap = null) {
    if (!targetMap) return;
    
    let portal, particles;
    
    if (direction === 'right') {
        portal = mapPortal = {
            element: document.createElement('div'),
            x: mapWidth - 150,
            y: screenHeight - groundHeight - 120,
            width: 80,
            height: 120,
            active: true,
            glowIntensity: 0,
            direction: 'right',
            targetMap: targetMap
        };
        particles = portalParticles;
    } else {
        portal = leftPortal = {
            element: document.createElement('div'),
            x: 70, // ë§µ ì¢Œì¸¡
            y: screenHeight - groundHeight - 120,
            width: 80,
            height: 120,
            active: true,
            glowIntensity: 0,
            direction: 'left',
            targetMap: targetMap
        };
        particles = leftPortalParticles;
    }
    
    portal.element.className = `map-portal ${direction}-portal`;
    portal.element.style.left = portal.x + 'px';
    portal.element.style.top = portal.y + 'px';
    
    // í¬í„¸ ë‚´ë¶€ êµ¬ì¡°
    portal.element.innerHTML = `
        <div class="portal-outer-ring"></div>
        <div class="portal-inner-ring"></div>
        <div class="portal-core"></div>
        <div class="portal-particles"></div>
    `;
    
    gameContainer.appendChild(portal.element);
    
    // í¬í„¸ë³„ íŒŒí‹°í´ ìƒì„±
    createPortalParticlesForPortal(portal, particles);
}

// íŠ¹ì • í¬í„¸ìš© íŒŒí‹°í´ ìƒì„±
function createPortalParticlesForPortal(portal, particleArray) {
    for (let i = 0; i < 15; i++) {
        const particle = {
            element: document.createElement('div'),
            x: portal.x + portal.width/2,
            y: portal.y + portal.height/2,
            angle: (Math.PI * 2 * i) / 15,
            radius: Math.random() * 30 + 20,
            speed: Math.random() * 0.02 + 0.01,
            opacity: Math.random() * 0.8 + 0.2,
            portalRef: portal
        };
        
        particle.element.className = 'portal-particle';
        particle.element.style.opacity = particle.opacity;
        gameContainer.appendChild(particle.element);
        particleArray.push(particle);
    }
}

// í¬í„¸ ë©”ì‹œì§€ ìƒì„±
function createPortalMessage() {
    if (document.getElementById('portalMessage')) return;
    
    const message = document.createElement('div');
    message.id = 'portalMessage';
    message.className = 'portal-message';
    message.innerHTML = `
        <div class="message-content">
            <div class="message-icon">ğŸŒ€</div>
            <div class="message-text">Zí‚¤ë¥¼ ëˆŒëŸ¬ ë‹¤ìŒ ë§µìœ¼ë¡œ ì´ë™</div>
        </div>
    `;
    
    gameContainer.appendChild(message);
}

// í¬í„¸ ë©”ì‹œì§€ ì œê±°
function removePortalMessage() {
    const message = document.getElementById('portalMessage');
    if (message) {
        message.remove();
    }
}

// í¬í„¸ ì—…ë°ì´íŠ¸ í•¨ìˆ˜ ìˆ˜ì •
function updatePortal() {
    updateSinglePortal(mapPortal, 'showPortalMessage');
    updateSinglePortal(leftPortal, 'showLeftPortalMessage');
}

// ë‹¨ì¼ í¬í„¸ ì—…ë°ì´íŠ¸
function updateSinglePortal(portal, messageFlag) {
    if (!portal) return;
    
    // ì¹´ë©”ë¼ ì˜¤í”„ì…‹ ì ìš©
    const screenX = portal.x - cameraX;
    portal.element.style.left = screenX + 'px';
    
    // í¬í„¸ê³¼ í”Œë ˆì´ì–´ ê±°ë¦¬ ê³„ì‚°
    const portalCenterX = portal.x + portal.width/2;
    const portalCenterY = portal.y + portal.height/2;
    const playerCenterX = playerX + playerSize/2;
    const playerCenterY = playerY + playerSize/2;
    
    const distance = Math.sqrt(
        Math.pow(portalCenterX - playerCenterX, 2) + 
        Math.pow(portalCenterY - playerCenterY, 2)
    );
    
    // í”Œë ˆì´ì–´ê°€ í¬í„¸ ê·¼ì²˜ì— ìˆëŠ”ì§€ í™•ì¸ (100px ì´ë‚´)
    if (distance < 100) {
        if (portal.direction === 'right' && !showPortalMessage) {
            showPortalMessage = true;
            createPortalMessage(portal.direction, portal.targetMap);
        } else if (portal.direction === 'left' && !showLeftPortalMessage) {
            showLeftPortalMessage = true;
            createPortalMessage(portal.direction, portal.targetMap);
        }
        
        portal.glowIntensity = Math.min(1, portal.glowIntensity + 0.02);
    } else {
        if (portal.direction === 'right' && showPortalMessage) {
            showPortalMessage = false;
            removePortalMessage();
        } else if (portal.direction === 'left' && showLeftPortalMessage) {
            showLeftPortalMessage = false;
            removePortalMessage();
        }
        
        portal.glowIntensity = Math.max(0.3, portal.glowIntensity - 0.02);
    }
    
    // í¬í„¸ ê¸€ë¡œìš° íš¨ê³¼ ì ìš©
    portal.element.style.filter = `brightness(${1 + portal.glowIntensity})`;
}

// í¬í„¸ íŒŒí‹°í´ ì—…ë°ì´íŠ¸
function updatePortalParticles() {
    portalParticles.forEach(particle => {
        // ì›í˜• ê¶¤ë„ë¡œ íšŒì „
        particle.angle += particle.speed;
        
        const centerX = mapPortal.x + mapPortal.width/2;
        const centerY = mapPortal.y + mapPortal.height/2;
        
        particle.x = centerX + Math.cos(particle.angle) * particle.radius;
        particle.y = centerY + Math.sin(particle.angle) * particle.radius;
        
        // ì¹´ë©”ë¼ ì˜¤í”„ì…‹ ì ìš©
        const screenX = particle.x - cameraX;
        particle.element.style.left = screenX + 'px';
        particle.element.style.top = particle.y + 'px';
        
        // íˆ¬ëª…ë„ ì• ë‹ˆë©”ì´ì…˜
        particle.opacity = 0.2 + Math.sin(particle.angle * 3) * 0.3;
        particle.element.style.opacity = Math.max(0.1, particle.opacity);
    });
}    
    // startGame í•¨ìˆ˜ ìˆ˜ì •
function startGame() {
    // íŠœí† ë¦¬ì–¼ ë§µìœ¼ë¡œ ì‹œì‘
    initializeMap('tutorial');
    gameLoop();
}
    
    // í˜ì´ì§€ ë¡œë“œ ì‹œ ì´ˆê¸°í™”
    window.onload = function() {
        // ê²Œì„ ì„¤ì • ë¡œë“œ
        google.script.run
            .withSuccessHandler(function(data) {
                if (data) {
                    moveSpeed = data.moveSpeed || moveSpeed;
                    jumpPower = data.jumpPower || jumpPower;
                    gravity = data.gravity || gravity;
                    bulletSpeed = data.bulletSpeed || bulletSpeed;
                    fireRate = data.fireRate || fireRate;
                }
                startGame();
            })
            .withFailureHandler(function(error) {
                console.log('ì„¤ì •ì„ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆì§€ë§Œ ê¸°ë³¸ê°’ìœ¼ë¡œ ì‹œì‘í•©ë‹ˆë‹¤.');
                startGame();
            })
            .getGameSettings();
    };
</script>
