<script>
    // ê²Œì„ ìš”ì†Œë“¤
    let player = document.getElementById('player');
    let gameContainer = document.getElementById('gameContainer');
    let coordinates = document.getElementById('coordinates');
    let gameStats = document.getElementById('gameStats');
    
    // ê²Œì„ ì„¤ì •
// í™”ë©´ í¬ê¸° (ë³´ì´ëŠ” í™”ë©´)
const screenWidth = 1800;
const screenHeight = 900;

// ì‹¤ì œ ë§µ í¬ê¸° (ê°€ìƒì˜ ë§µ, 2ë°°)
const mapWidth = 3600;
const mapHeight = 900;

// ì¹´ë©”ë¼ ì˜¤í”„ì…‹
let cameraX = 0;
    const playerSize = 40;
    const groundHeight = 90;
    
    // í”Œë ˆì´ì–´ ìƒíƒœ
    let playerX = 100;
    let playerY = screenHeight - groundHeight - playerSize;
    let velocityX = 0;
    let velocityY = 0;
    
    // ê²Œì„ ì„¤ì • (êµ¬ê¸€ ì‹œíŠ¸ì—ì„œ ê°€ì ¸ì˜¬ ê°’ë“¤)
    let moveSpeed = 7;
    let jumpPower = 15;
    let gravity = 0.6;
    let friction = 0.8;
    let airResistance = 0.95;
    let bulletSpeed = 10;
    let fireRate = 300; // ë°€ë¦¬ì´ˆ
    
    // ì£¼ì‚¬ìœ„ ê´€ë ¨ ë³€ìˆ˜
    let diceArray = [];
    let diceShot = 0;
    let totalDamage = 0;
    let lastFireTime = 0;

    //êµ¬ë¦„ ê´€ë ¨ ë³€ìˆ˜
    let clouds = [];

    //íŠœí† ë¦¬ì–¼ ë³€ìˆ˜
    let tutorialSigns = [];

    // ì  ê´€ë ¨ ë³€ìˆ˜ (ìƒˆë¡œ ì¶”ê°€)
    let enemies = [];
    let damageIndicators = [];
    
    // ì…ë ¥ ìƒíƒœ
    let keys = {
    left: false,
    right: false,
    jump: false,
    shoot: false,
    arrowLeft: false,
    arrowRight: false,
    arrowUp: false,
    arrowDown: false
};
    
    let isOnGround = false;
    //ê²Œì„ ë£¨í”„
    function gameLoop() {
    handleInput();
    updatePhysics();
    updateDice();
    updateEnemies();          // ì¶”ê°€
    updateDamageIndicators(); // ì¶”ê°€
    checkDiceEnemyCollisions(); // ì¶”ê°€
    updatePlayerPosition();
    updateTutorialSigns(); //íŠœí† ë¦¬ì–¼
    updateClouds();
    updateUI();
    requestAnimationFrame(gameLoop);
}
    
    // ì…ë ¥ ì²˜ë¦¬
function handleInput() {
    // ë””ë²„ê¹…ìš© - keys ìƒíƒœ í™•ì¸
    if (keys.left || keys.right || keys.jump || keys.shoot || keys.arrowLeft || keys.arrowRight || keys.arrowUp || keys.arrowDown) {
        console.log('Keys active:', keys);
    }
    
    // ì¢Œìš° ì´ë™ (ë•…ì—ì„œ ë” ë¹ ë¥´ê²Œ)
    if (keys.left) {
        console.log('Moving left!'); // ë””ë²„ê¹…ìš©
        if (isOnGround) {
            velocityX -= moveSpeed * 1.0;
        } else {
            velocityX -= moveSpeed * 0.1;
        }
    }
    if (keys.right) {
        console.log('Moving right!'); // ë””ë²„ê¹…ìš©
        if (isOnGround) {
            velocityX += moveSpeed * 0.15;
        } else {
            velocityX += moveSpeed * 0.1;
        }
    }
    
    // ì í”„ (ë•…ì— ìˆì„ ë•Œë§Œ)
    if (keys.jump && isOnGround) {
        console.log('Jumping!'); // ë””ë²„ê¹…ìš©
        velocityY = -jumpPower;
        isOnGround = false;
    }
    
    // ì£¼ì‚¬ìœ„ ë°œì‚¬ (Sí‚¤)
    if (keys.shoot) {
        console.log('Shooting!'); // ë””ë²„ê¹…ìš©
        fireDice(); // ê¸°ë³¸ ìš°ì¸¡ ë°œì‚¬
    }
    
    // í™”ì‚´í‘œí‚¤ë¡œ ë°©í–¥ ë°œì‚¬
    if (keys.arrowLeft) {
        fireDice(-1, 0); // ì™¼ìª½
    }
    if (keys.arrowRight) {
        fireDice(1, 0); // ì˜¤ë¥¸ìª½
    }
    if (keys.arrowUp) {
        fireDice(0, -1); // ìœ„ìª½
    }
    if (keys.arrowDown) {
        fireDice(0, 1); // ì•„ë˜ìª½
    }
}

    // ì£¼ì‚¬ìœ„ ëˆˆ ìƒì„± í•¨ìˆ˜ - ê°œì„ ëœ ë²„ì „
    function createDiceFace(value) {
        let dotsHTML = '';
        
        // ì£¼ì‚¬ìœ„ ëˆˆì— ë”°ë¼ ì  ìƒì„±
        for (let i = 0; i < value; i++) {
            dotsHTML += '<div class="dice-dot"></div>';
        }
        
        return dotsHTML;
    }

    // ì£¼ì‚¬ìœ„ ë°œì‚¬ í•¨ìˆ˜
    function fireDice(directionX = 1, directionY = 0) {
    const currentTime = Date.now();
    if (currentTime - lastFireTime < fireRate) return;
    
    lastFireTime = currentTime;
    diceShot++;




    // ì£¼ì‚¬ìœ„ ìƒì„±
    const dice = {
        element: document.createElement('div'),
        x: playerX + playerSize / 2,
        y: playerY + playerSize / 2,
        velocityX: bulletSpeed * directionX,
        velocityY: bulletSpeed * directionY,
        value: Math.floor(Math.random() * 6) + 1,
        life: 300,
        rollCounter: 0
    };
        
        // ì£¼ì‚¬ìœ„ ìš”ì†Œ ì„¤ì •
        dice.element.className = `dice dice-face-${dice.value}`;
        dice.element.innerHTML = createDiceFace(dice.value);
        dice.element.style.left = dice.x + 'px';
        dice.element.style.top = dice.y + 'px';
        
        gameContainer.appendChild(dice.element);
        diceArray.push(dice);
        
        totalDamage += dice.value;
    }
    // í—ˆìˆ˜ì•„ë¹„ ìƒì„± í•¨ìˆ˜
    function createTrainingDummy() {
        const dummy = {
            element: document.createElement('div'),
            x: mapWidth - 200, // ë§µì˜ ìš°ì¸¡ ë ê·¼ì²˜ì— ë°°ì¹˜
            y: screenHeight - groundHeight - 60,
            width: 40,
            height: 60,
            maxHp: 1000,
            currentHp: 1000,
            type: 'dummy'
        };
        
        dummy.element.className = 'training-dummy';
        dummy.element.style.left = dummy.x + 'px';
        dummy.element.style.top = dummy.y + 'px';
        
        const hpBar = document.createElement('div');
        hpBar.className = 'enemy-hp-bar';
        hpBar.innerHTML = `
            <div class="hp-bar-background">
                <div class="hp-bar-fill"></div>
                <div class="hp-bar-text">${dummy.currentHp}/${dummy.maxHp}</div>
            </div>
        `;
        dummy.element.appendChild(hpBar);
        
        gameContainer.appendChild(dummy.element);
        enemies.push(dummy);
    }

    // ì  ì—…ë°ì´íŠ¸ í•¨ìˆ˜
function updateEnemies() {
    enemies.forEach(enemy => {
        // ì¹´ë©”ë¼ ì˜¤í”„ì…‹ ì ìš©
        const screenX = enemy.x - cameraX;
        enemy.element.style.left = screenX + 'px';
        
        if (enemy.type === 'dummy') {
            const hpFill = enemy.element.querySelector('.hp-bar-fill');
            const hpText = enemy.element.querySelector('.hp-bar-text');
            
            const hpPercent = (enemy.currentHp / enemy.maxHp) * 100;
            hpFill.style.width = hpPercent + '%';
            hpText.textContent = `${enemy.currentHp}/${enemy.maxHp}`;
        }
    });
}

    // ë°ë¯¸ì§€ í‘œì‹œê¸° ìƒì„± (ë°˜ì› ë²”ìœ„)
function createDamageIndicator(enemyX, enemyY, enemyWidth, diceValue) {
    // ì ì˜ ë¨¸ë¦¬ ì¤‘ì•™ ìœ„ì¹˜
    const headCenterX = enemyX + enemyWidth / 2;
    const headY = enemyY - 10; // ë¨¸ë¦¬ ìœ„ìª½
    
    // ë°˜ì› ë²”ìœ„ì—ì„œ ëœë¤ ìœ„ì¹˜ ê³„ì‚°
    const radius = 40; // ë°˜ì› ë°˜ì§€ë¦„
    const angle = Math.random() * Math.PI; // 0 ~ Ï€ (ë°˜ì›)
    
    const offsetX = Math.cos(angle) * (Math.random() * radius);
    const offsetY = -Math.sin(angle) * (Math.random() * radius); // ìœ„ìª½ìœ¼ë¡œë§Œ
    
    const indicator = {
        element: document.createElement('div'),
        x: headCenterX + offsetX,
        y: headY + offsetY,
        life: 150, // ì¡°ê¸ˆ ë” ì§§ê²Œ
        diceValue: diceValue
    };
    
    indicator.element.className = 'damage-indicator';
    indicator.element.textContent = `-${diceValue}`;
    
    // ì¹´ë©”ë¼ ì˜¤í”„ì…‹ ì ìš©ëœ ìœ„ì¹˜
    const screenX = indicator.x - cameraX;
    indicator.element.style.left = screenX + 'px';
    indicator.element.style.top = indicator.y + 'px';
    
    gameContainer.appendChild(indicator.element);
    damageIndicators.push(indicator);
}

    // ë°ë¯¸ì§€ í‘œì‹œê¸° ì—…ë°ì´íŠ¸
function updateDamageIndicators() {
    for (let i = damageIndicators.length - 1; i >= 0; i--) {
        const indicator = damageIndicators[i];
        
        // ì¹´ë©”ë¼ ì˜¤í”„ì…‹ ì ìš©
        const screenX = indicator.x - cameraX;
        indicator.element.style.left = screenX + 'px';
        
        indicator.life--;
        
        if (indicator.life < 60) {
            const opacity = indicator.life / 60;
            indicator.element.style.opacity = opacity;
        }
        
        if (indicator.life <= 0) {
            indicator.element.remove();
            damageIndicators.splice(i, 1);
        }
    }
}

    // ì£¼ì‚¬ìœ„ì™€ ì  ì¶©ëŒ ê²€ì‚¬
    function checkDiceEnemyCollisions() {
        for (let i = diceArray.length - 1; i >= 0; i--) {
            const dice = diceArray[i];
            
            for (let j = 0; j < enemies.length; j++) {
                const enemy = enemies[j];
                
                if (dice.x < enemy.x + enemy.width &&
                    dice.x + 25 > enemy.x &&
                    dice.y < enemy.y + enemy.height &&
                    dice.y + 25 > enemy.y) {
                    
                    enemy.currentHp -= dice.value;
                    if (enemy.currentHp < 0) enemy.currentHp = 0;
                    
                    createDamageIndicator(enemy.x, enemy.y, enemy.width, dice.value);
                    
                    dice.element.remove();
                    diceArray.splice(i, 1);
                    break;
                }
            }
        }
    }
    // ì£¼ì‚¬ìœ„ ì—…ë°ì´íŠ¸
    function updateDice() {
        for (let i = diceArray.length - 1; i >= 0; i--) {
            const dice = diceArray[i];
            
            // ì£¼ì‚¬ìœ„ ì´ë™
            dice.x += dice.velocityX;
            dice.y += dice.velocityY;
            
            // ì£¼ì‚¬ìœ„ ëˆˆ ëœë¤ ë³€ê²½ (ë” ì•ˆì •ì ìœ¼ë¡œ)
            dice.rollCounter++;
            if (dice.rollCounter % 40 === 0) { // 20í”„ë ˆì„ë§ˆë‹¤ ë³€ê²½ (ë” ì²œì²œíˆ)
                const oldValue = dice.value;
                dice.value = Math.floor(Math.random() * 6) + 1;
                
                // ê°’ì´ ë°”ë€Œì—ˆì„ ë•Œë§Œ ì—…ë°ì´íŠ¸
                if (oldValue !== dice.value) {
                    dice.element.className = `dice dice-face-${dice.value}`;
                    dice.element.innerHTML = createDiceFace(dice.value);
                    
                    // ì´ ë°ë¯¸ì§€ ì—…ë°ì´íŠ¸ (ì´ì „ ê°’ ë¹¼ê³  ìƒˆ ê°’ ë”í•˜ê¸°)
                    totalDamage = totalDamage - oldValue + dice.value;
                }
            }
            
            // ìœ„ì¹˜ ì—…ë°ì´íŠ¸ (ì¹´ë©”ë¼ ì˜¤í”„ì…‹ ì ìš©)
const screenX = dice.x - cameraX;
dice.element.style.left = screenX + 'px';
dice.element.style.top = dice.y + 'px';
            
            // ìˆ˜ëª… ê°ì†Œ
            dice.life--;
            
            // ë§µ ë°–ìœ¼ë¡œ ë‚˜ê°€ê±°ë‚˜ ìˆ˜ëª…ì´ ë‹¤í•˜ë©´ ì œê±°
if (dice.x > mapWidth || dice.y > screenHeight || dice.life <= 0 || dice.x < 0) {
                dice.element.remove();
                diceArray.splice(i, 1);
            }
        }
    }
    
    // UI ì—…ë°ì´íŠ¸
    function updateUI() {
        gameStats.textContent = `ì£¼ì‚¬ìœ„: ${diceShot}ë°œ | ì´ ë°ë¯¸ì§€: ${totalDamage}`;
    }
   
    // êµ¬ë¦„ ìƒì„± í•¨ìˆ˜
function createClouds() {
    const cloudTypes = ['cloud-small', 'cloud-medium', 'cloud-large'];
    
    for (let i = 0; i < 8; i++) {
        const cloud = {
            element: document.createElement('div'),
            x: Math.random() * mapWidth,
            y: Math.random() * 200 + 50, // í•˜ëŠ˜ ìœ„ìª½ì—ë§Œ
            type: cloudTypes[Math.floor(Math.random() * cloudTypes.length)]
        };
        
        cloud.element.className = `cloud ${cloud.type}`;
        cloud.element.style.left = cloud.x + 'px';
        cloud.element.style.top = cloud.y + 'px';
        
        gameContainer.appendChild(cloud.element);
        clouds.push(cloud);
    }
}

// êµ¬ë¦„ ìœ„ì¹˜ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
function updateClouds() {
    clouds.forEach(cloud => {
        // ì¹´ë©”ë¼ ì˜¤í”„ì…‹ ì ìš©
        const screenX = cloud.x - cameraX;
        cloud.element.style.left = screenX + 'px';
    });
}
// íŠœí† ë¦¬ì–¼ ì‚¬ì¸ ìƒì„± í•¨ìˆ˜
function createTutorialSigns() {
    const tutorials = [
        {
            x: 400,
            y: screenHeight - groundHeight - 180,
            text: "A/Dí‚¤ë¡œ\nì¢Œìš° ì´ë™",
            arrow: "â†â†’"
        },
        {
            x: 900,
            y: screenHeight - groundHeight - 180,
            text: "ìŠ¤í˜ì´ìŠ¤ë°”ë¡œ\nì í”„",
            arrow: "â†‘"
        },
        {
            x: 1400,
            y: screenHeight - groundHeight - 180,
            text: "í™”ì‚´í‘œí‚¤ë¡œ\nì£¼ì‚¬ìœ„ ë°œì‚¬",
            arrow: "ğŸ²"
        },
        {
            x: mapWidth - 500,
            y: screenHeight - groundHeight - 200,
            text: "í—ˆìˆ˜ì•„ë¹„ë¥¼\nê³µê²©í•´ë³´ì„¸ìš”!",
            arrow: "ğŸ¯"
        }
    ];
    
    tutorials.forEach((tutorial, index) => {
        // ì‚¬ì¸ ìƒì„±
        const sign = {
            element: document.createElement('div'),
            x: tutorial.x,
            y: tutorial.y,
            id: `tutorial-${index}`
        };
        
        sign.element.className = 'tutorial-sign';
        sign.element.innerHTML = tutorial.text.replace('\n', '<br>');
        sign.element.style.left = tutorial.x + 'px';
        sign.element.style.top = tutorial.y + 'px';
        
        gameContainer.appendChild(sign.element);
        tutorialSigns.push(sign);
        
        // í™”ì‚´í‘œ ìƒì„±
        const arrow = {
            element: document.createElement('div'),
            x: tutorial.x,
            y: tutorial.y - 40,
            signIndex: index
        };
        
        arrow.element.className = 'tutorial-arrow';
        arrow.element.textContent = tutorial.arrow;
        arrow.element.style.left = (tutorial.x + 100) + 'px';
        arrow.element.style.top = (tutorial.y - 40) + 'px';
        
        gameContainer.appendChild(arrow.element);
        tutorialSigns.push(arrow);
    });
}

// íŠœí† ë¦¬ì–¼ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
function updateTutorialSigns() {
    tutorialSigns.forEach(sign => {
        // ì¹´ë©”ë¼ ì˜¤í”„ì…‹ ì ìš©
        const screenX = sign.x - cameraX;
        sign.element.style.left = screenX + 'px';
    });
}
    // ë¬¼ë¦¬ ì—”ì§„
    function updatePhysics() {
        // ì¤‘ë ¥ ì ìš©
        velocityY += gravity;
        
        // ê³µê¸° ì €í•­
if (!isOnGround) {
    velocityX *= airResistance;
} else {
    // ë•…ì—ì„œì˜ ë§ˆì°°
    velocityX *= friction;
}
        
        // ìµœëŒ€ ì†ë„ ì œí•œ
        const maxVelocityX = moveSpeed;
        const maxVelocityY = 25;
        
        if (velocityX > maxVelocityX) velocityX = maxVelocityX;
        if (velocityX < -maxVelocityX) velocityX = -maxVelocityX;
        if (velocityY > maxVelocityY) velocityY = maxVelocityY;
        
        // ìœ„ì¹˜ ì—…ë°ì´íŠ¸
        playerX += velocityX;
        playerY += velocityY;
        
        // ê²½ê³„ ì¶©ëŒ ê²€ì‚¬
        checkCollisions();
    }
    
    // ì¶©ëŒ ê²€ì‚¬
    function checkCollisions() {
        // ì¢Œìš° ë²½ ì¶©ëŒ (ë§µ í¬ê¸° ê¸°ì¤€)
if (playerX < 0) {
    playerX = 0;
    velocityX = 0;
}
if (playerX > mapWidth - playerSize) {
    playerX = mapWidth - playerSize;
    velocityX = 0;
}
        
        // ë•… ì¶©ëŒ
        // ë•… ì¶©ëŒ (ìºë¦­í„° ë°œì´ ë•… í‘œë©´ì— ì •í™•íˆ ë‹¿ë„ë¡)
const groundSurfaceY = screenHeight - groundHeight; // ë•…ì˜ í‘œë©´ ìœ„ì¹˜
const groundY = groundSurfaceY - playerSize; // ìºë¦­í„°ê°€ ë•… ìœ„ì— ì„œëŠ” ìœ„ì¹˜
if (playerY >= groundY) {
    playerY = groundY;
    velocityY = 0;
    isOnGround = true;
} else {
    isOnGround = false;
}
        
        // ì²œì¥ ì¶©ëŒ
        if (playerY < 0) {
            playerY = 0;
            velocityY = 0;
        }
    }
    
    // í”Œë ˆì´ì–´ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
function updatePlayerPosition() {
    updateCamera();
    
    // ì¹´ë©”ë¼ ì˜¤í”„ì…‹ì„ ì ìš©í•œ í™”ë©´ìƒ ìœ„ì¹˜
    const screenX = playerX - cameraX;
    
    player.style.left = Math.round(screenX) + 'px';
    player.style.top = Math.round(playerY) + 'px';
    coordinates.textContent = `X: ${Math.round(playerX)}, Y: ${Math.round(playerY)} | Camera: ${Math.round(cameraX)}`;
}

// ì¹´ë©”ë¼ ì—…ë°ì´íŠ¸ í•¨ìˆ˜ (ë¶€ë“œëŸ¬ìš´ ì „í™˜)
function updateCamera() {
    const followPosition = screenWidth * 1/3; // 600px
    const leftBoundary = followPosition; // 600px
const rightBoundary = mapWidth - (screenWidth - followPosition); // 2400px
    
    let targetCameraX;
    
    if (playerX < leftBoundary) {
        // ì¢Œì¸¡ êµ¬ê°„: ì¹´ë©”ë¼ ê³ ì •
        targetCameraX = 0;
    } else if (playerX > rightBoundary) {
        // ìš°ì¸¡ êµ¬ê°„: ì¹´ë©”ë¼ ê³ ì •
        targetCameraX = mapWidth - screenWidth;
    } else {
        // ì¤‘ê°„ êµ¬ê°„: ìºë¦­í„° ë”°ë¼ê°€ê¸°
        targetCameraX = playerX - followPosition;
    }
    
    // ë¶€ë“œëŸ¬ìš´ ì¹´ë©”ë¼ ì´ë™ (ì„ íƒì‚¬í•­)
    // cameraX += (targetCameraX - cameraX) * 0.1;
    
    // ì¦‰ì‹œ ì´ë™
    cameraX = targetCameraX;
}
    
    // í‚¤ë³´ë“œ ì´ë²¤íŠ¸ ì²˜ë¦¬
    document.addEventListener('keydown', function(event) {
        console.log('Key pressed:', event.key, event.code); // ë””ë²„ê¹…ìš©
        
        switch(event.key.toLowerCase()) {
            case 'a':
                keys.left = true;
                event.preventDefault();
                break;
            case 'd':
                keys.right = true;
                event.preventDefault();
                break;
            case ' ': //ìŠ¤í˜ì´ìŠ¤ ë°”
                keys.jump = true;
                event.preventDefault();
                break;
            case 's':
                keys.shoot = true;
                event.preventDefault();
                break;
            case 'arrowleft':
                keys.arrowLeft = true;
                event.preventDefault();
                break;
            case 'arrowright':
                keys.arrowRight = true;
                event.preventDefault();
                break;
            case 'arrowup':
                keys.arrowUp = true;
                event.preventDefault();
                break;
            case 'arrowdown':
                keys.arrowDown = true;
                event.preventDefault();
                break;
        }
    });
    
    document.addEventListener('keyup', function(event) {
        switch(event.key.toLowerCase()) {
            case 'a':
                keys.left = false;
                event.preventDefault();
                break;
            case 'd':
                keys.right = false;
                event.preventDefault();
                break;
            case ' ': // ìŠ¤í˜ì´ìŠ¤ë°”
                keys.jump = false;
                event.preventDefault();
                break;
            case 's':
                keys.shoot = false;
                event.preventDefault();
                break;
            case 'arrowleft':
                keys.arrowLeft = false;
                event.preventDefault();
                break;
            case 'arrowright':
                keys.arrowRight = false;
                event.preventDefault();
                break;
            case 'arrowup':
                keys.arrowUp = false;
                event.preventDefault();
                break;
            case 'arrowdown':
                keys.arrowDown = false;
                event.preventDefault();
                break;
        }
    });
    
    // êµ¬ê¸€ ì‹œíŠ¸ ì—°ë™ í•¨ìˆ˜ë“¤
    function loadPosition() {
        google.script.run
            .withSuccessHandler(function(data) {
                playerX = data.playerX;
                playerY = data.playerY;
                moveSpeed = data.moveSpeed;
                jumpPower = data.jumpPower;
                gravity = data.gravity;
                
                // ì†ë„ ì´ˆê¸°í™”
                velocityX = 0;
                velocityY = 0;
                
                updatePlayerPosition();
                alert('ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤!');
            })
            .withFailureHandler(function(error) {
                alert('ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ' + error);
            })
            .getGameData();
    }
    
    function savePosition() {
        google.script.run
            .withSuccessHandler(function(result) {
                alert('ìœ„ì¹˜ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!');
            })
            .withFailureHandler(function(error) {
                alert('ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ' + error);
            })
            .saveGameData(Math.round(playerX), Math.round(playerY));
    }
    
    function resetPosition() {
        google.script.run
            .withSuccessHandler(function(result) {
                playerX = 100;
                playerY = screenHeight - groundHeight - playerSize; // ë•… í‘œë©´ ë°”ë¡œ ìœ„
                velocityX = 0;
                velocityY = 0;
                diceShot = 0;
                totalDamage = 0;
                
                // ëª¨ë“  ì£¼ì‚¬ìœ„ ì œê±°
                diceArray.forEach(dice => dice.element.remove());
                diceArray = [];
                
                updatePlayerPosition();
                alert('ê²Œì„ì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤!');
            })
            .withFailureHandler(function(error) {
                alert('ì´ˆê¸°í™”ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ' + error);
            })
            .resetGame();
    }
    
    // ê²Œì„ ì‹œì‘
    function startGame() {
        updatePlayerPosition();
        createTrainingDummy(); // í—ˆìˆ˜ì•„ë¹„ ìƒì„±
        gameLoop();
        createClouds();
        createTutorialSigns();
    }
    
    // í˜ì´ì§€ ë¡œë“œ ì‹œ ì´ˆê¸°í™”
    window.onload = function() {
        // ê²Œì„ ì„¤ì • ë¡œë“œ
        google.script.run
            .withSuccessHandler(function(data) {
                if (data) {
                    moveSpeed = data.moveSpeed || moveSpeed;
                    jumpPower = data.jumpPower || jumpPower;
                    gravity = data.gravity || gravity;
                    bulletSpeed = data.bulletSpeed || bulletSpeed;
                    fireRate = data.fireRate || fireRate;
                }
                startGame();
            })
            .withFailureHandler(function(error) {
                console.log('ì„¤ì •ì„ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆì§€ë§Œ ê¸°ë³¸ê°’ìœ¼ë¡œ ì‹œì‘í•©ë‹ˆë‹¤.');
                startGame();
            })
            .getGameSettings();
    };
</script>
